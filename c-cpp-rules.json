{
    "name": "C/C++安全规则集合",
    "version": "1.1.0",
    "encoding": "utf-8",

    "//": [
        "checkPoint是规则的描述",
        "comment是规则针对问题的简要说明",
        "config是相关配置项的名称及含义",
        "standard是相关ISO/IEC标准",
        "reference是规则的参考条目，由逗号分隔",
        "level是严重性等级，分为error、warning、suggestion、suspicious",
            "error：错误代码",
            "warning：有严重错误倾向的代码",
            "suggestion：优化建议",
            "suspicious：可疑的代码，不一定有实际错误",
        "tags是进一步细化的分类"
    ],

    "ID_sizeof_oddExpression": {
        "checkPoint": "sizeof 不应作用于逻辑表达式",
        "level": "warning",
        "comment": "sizeof作用于 <、>、<=、>=、==、!=、&&、|| 等逻辑表达式为常见笔误，逻辑运算符往往应该移出 sizeof 表达式。",
        "tag": "expression"
        },
    "ID_sizeof_pointerDivision": {
        "checkPoint": "被除数不应是作用于指针的 sizeof 表达式",
        "level": "warning",
        "comment": "形如 sizeof(p)/n 的表达式往往是为了获取数组元素的个数，如果 p 是指针，sizeof(p) 只是指针变量的大小，并不是数组的大小，所以这种表达式往往意味着逻辑错误。",
        "tag": "expression",
        "related": "ID_sizeof_pointer",
        "reference": "CWE-467"
        },
    "ID_sizeof_void": {
        "checkPoint": "sizeof 不可作用于 void",
        "level": "error",
        "comment": "void 表示不存在的类型，也是不完整的类型，sizeof 作用于 void 是没意义的，属于语言运用错误，也可能是 sizeof(void*) 的笔误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.3.2.2(1),ISO/IEC 9899:1999 6.2.5(19)"
        },
    "ID_differentEnumComparison": {
        "checkPoint": "不应比较非同类枚举值",
        "level": "warning",
        "comment": "比较非同类枚举值相当于比较不同类别的事物，没有逻辑意义，往往是设计缺陷或逻辑错误。",
        "tag": "expression"
        },
    "ID_ptrIntCast": {
        "checkPoint": "指针与整数不应相互转换",
        "level": "warning",
        "comment": "指针转为整数，或整数转为指针（尤其是小于 64 位的整数或有符号的整数），容易造成地址不完整、寻址错误、降低可移植性等问题。",
        "tag": "cast",
        "standard": "ISO/IEC 9899:2011 6.3.2.3(5)-implementation,ISO/IEC 14882:2003 5.2.10(4 5)-implementation,ISO/IEC 14882:2011 5.2.10(4 5)-implementation",
        "reference": "SEI CERT INT36-C,MISRA C 2004 11.3,MISRA C 2012 11.4,MISRA C++ 2008 5-2-8,MISRA C++ 2008 5-2-9"
        },
    "ID_zeroAsPtrValue": {
        "checkPoint": "不应使用常数 0 对指针赋值",
        "level": "suggestion",
        "comment": "不应使用常数 0 对指针赋值，在 C++ 代码中应使用 nullptr，在 C 代码中应使用 NULL，否则易出现类型转换相关的错误，且不利于阅读。",
        "tag": "pointer",
        "reference": "MISRA C++ 2008 4-10-2,C++ Core Guidelines ES.47"
        },
    "ID_charWCharCast": {
        "checkPoint": "不可直接转换不同的字符串类型",
        "level": "warning",
        "comment": "char* 和 wchar_t* 直接转换并不进行字符集编码转换，往往意味着语言运用错误，char*、wchar_t*、char16_t* 和 char32_t* 之间均不可直接转换。",
        "tag": "cast",
        "related": "ID_castNoInheritance,ID_plainBinaryChar",
        "reference": "CWE-704,SEI CERT STR38-C"
        },
    "ID_repeatedUnaryOperators": {
        "checkPoint": "不应重复使用一元运算符",
        "level": "warning",
        "comment": "重复的一元运算符没有意义，为常见笔误。",
        "tag": "expression"
        },
    "ID_minusOnUnsigned": {
        "checkPoint": "负号不应作用于无符号整数",
        "level": "warning",
        "comment": "负号作用于无符号整数，结果仍是无符号整数，令人费解易产生意料之外的错误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.5.3.3(3),ISO/IEC 9899:2011 6.5.3.3(3)",
        "reference": "MISRA C 2004 12.9,MISRA C 2012 10.1,MISRA C++ 2008 5-3-2"
        },
    "ID_bitwiseOperOnSigned": {
        "checkPoint": "位运算符不应作用于有符号整数",
        "level": "warning",
        "comment": "符号位在位运算方面没有逻辑意义，对负数进行位运算往往意味着逻辑错误。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2011 5.8(2)-undefined,ISO/IEC 14882:2011 5.8(3)-implementation",
        "reference": "CWE-682,MISRA C 2004 12.7,MISRA C 2012 10.1,MISRA C++ 2008 5-0-21,C++ Core Guidelines ES.101"
        },
    "ID_simplifiableTernary": {
        "checkPoint": "可化简为逻辑表达式的三元表达式应尽量化简",
        "level": "suggestion",
        "comment": "当三元表达式的分枝是 true 或 false 时可化简为逻辑表达式，应化简代码。",
        "tag": "expression"
        },
    "ID_stickyAssignmentOperator": {
        "checkPoint": "赋值运算符与单目运算符之间应有空格，单目运算符与变量或表达式之间不应有空格",
        "level": "warning",
        "comment": "如果赋值运算符与之后的 +、-、*、!、&、~ 等单目运算符之间没有空格，而单目运算符与变量或表达式之间有空格，是一种非常怪异的格式，造成阅读困难，而且也可能是 +=、-=、*=、&=、~= 等复合赋值相关的笔误。",
        "tag": "expression",
        "reference": "CWE-480"
        },
    "ID_redundantParentheses": {
        "checkPoint": "不应使用多余的括号",
        "level": "suggestion",
        "comment": "多余的括号使代码显得繁琐，应当去掉。",
        "tag": "expression"
        },
    "ID_throwNULL": {
        "checkPoint": "不应抛出 NULL",
        "level": "warning",
        "comment": "在 C++ 语言中，虽然 NULL 表示空指针，然而在多数环境中 throw NULL 相当于 throw 0，类型的不明确会造成对异常的错误捕捉。",
        "tag": "exception",
        "related": "ID_deprecatedNULL,ID_throwNonExceptionType,ID_throwPointer",
        "standard": "ISO/IEC 14882:2003 C.2.2.3(1)-implementation,ISO/IEC 14882:2011 C.3.2.4(1)-implementation,ISO/IEC 14882:2017 C.5.2.7(1)-implementation",
        "reference": "CWE-351,MISRA C++ 2008 15-1-2"
        },
    "ID_throwNullptr": {
        "checkPoint": "不应抛出 nullptr",
        "level": "warning",
        "comment": "nullptr 可被所有接受指针的 catch 块捕捉，使异常处理失去针对性，故不应抛出 nullptr。",
        "tag": "exception",
        "related": "ID_throwPointer",
        "reference": "MISRA C++ 2008 15-0-2"
        },
    "ID_throwNonExceptionType": {
        "checkPoint": "不应抛出非异常类型的对象",
        "level": "warning",
        "comment": "字符串或普通变量以及非异常相关的对象不应被当作异常抛出，否则意味着异常相关的设计是不健全的。",
        "tag": "exception",
        "related": "ID_catch_nonExceptionType",
        "reference": "C++ Core Guidelines E.14,C++ Core Guidelines E.3"
        },
    "ID_throwGenericException": {
        "checkPoint": "不应抛出过于宽泛的异常",
        "level": "warning",
        "comment": "抛出过于宽泛的异常如 std::exception、std::logic_error、std::runtime_error 等，使异常处理失去针对性，无法做到具体问题具体处理，而且处理这种异常时很可能将本不应处理的异常一并捕获，造成混乱。",
        "tag": "exception",
        "related": "ID_catch_generic",
        "reference": "CWE-397"
        },
    "ID_rethrowOutOfCatch": {
        "checkPoint": "不应在 catch 块外使用空 throw 表达式（throw;）",
        "level": "warning",
        "comment": "空 throw 表达式用于重新抛出当前捕获的异常，用在 catch 块外是危险的，增大了流程控制的复杂性。",
        "tag": "exception",
        "standard": "ISO/IEC 14882:2003 15.1(6 8),ISO/IEC 14882:2003 15.3(9)-implementation,ISO/IEC 14882:2011 15.1(8 9),ISO/IEC 14882:2011 15.3(9)-implementation",
        "reference": "MISRA C++ 2008 15-1-3"
        },
    "ID_improperRethrow": {
        "checkPoint": "重新抛出异常时应使用空 throw 表达式（throw;）",
        "level": "warning",
        "comment": "重新抛出异常时应使用空 throw 表达式，避免异常对象的精度损失或不必要的复制。",
        "tag": "exception",
        "standard": "ISO/IEC 14882:2003 15.1(6),ISO/IEC 14882:2011 15.1(8)"
        },
    "ID_forbidException": {
        "checkPoint": "禁用 C++ 异常",
        "level": "warning",
        "comment": "禁用 C++ 异常。",
        "tag": "exception",
        "related": "ID_exceptionUnsafe",
        "reference": "C++ Core Guidelines E.6,Google C++ Style Guide.Other C++ Features.Exceptions"
        },
    "ID_invalidExternSpecifier": {
        "checkPoint": "extern 关键字不应作用于类成员的声明或定义",
        "level": "warning",
        "comment": "extern 关键字作用于类成员的声明或定义是没有意义的，为语言用法错误。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 9.2(6),ISO/IEC 14882:2011 9.2(6),ISO/IEC 14882:2017 12.2(9)"
        },
    "ID_invalidParamArraySize": {
        "checkPoint": "不应将数组作为函数的形式参数",
        "level": "warning",
        "comment": "在形式参数中对数组大小的声明起不到实际的限制作用。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.7.5.3(7),ISO/IEC 9899:2011 6.7.6.3(7)",
        "reference": "C++ Core Guidelines I.13,C++ Core Guidelines R.14,MISRA C++ 2008 5-2-12"
        },
    "ID_illMemberCall": {
        "checkPoint": "基类对象构造完毕之前不可调用成员函数",
        "level": "warning",
        "comment": "基类对象未构造完毕时调用成员函数会导致标准未定义的错误。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2011 12.6.2(13)-undefined"
        },
    "ID_incompleteVAMacros": {
        "checkPoint": "va_start 或 va_copy 应配合 va_end 使用",
        "level": "warning",
        "comment": "可变参数列表相关的 va_start 或 va_copy 和 va_end 应在同一函数中使用，否则会导致标准未定义的错误。",
        "tag": "function",
        "related": "ID_forbidVariadicFunction",
        "standard": "ISO/IEC 9899:2011 7.16.1.3(2)-undefined"
        },
    "ID_functionSpecialization": {
        "checkPoint": "函数模版不应被特化",
        "level": "warning",
        "comment": "特化的函数模板不参与重载函数的选取，不属于常规用法，且容易造成混乱。",
        "tag": "function",
        "reference": "C++ Core Guidelines T.144,MISRA C++ 2008 14-8-1"
        },
    "ID_tooManyLines": {
        "checkPoint": "函数的行数应在规定范围之内",
        "level": "warning",
        "comment": "函数体过大违反模块化编程理念，使人难以阅读，更不便于维护，很有可能隐藏着各种错误，应适当重构。",
        "config": {
            "ID_function/maxLineCount": "行数上限，超过则报出"
            },
        "tag": "function",
        "reference": "C++ Core Guidelines F.2,C++ Core Guidelines F.3"
        },
    "ID_unsuitableCapture": {
        "checkPoint": "合理设置 lambda 表达式对变量的捕获方式",
        "level": "warning",
        "comment": "如果 lambda 表达式只在函数内部使用，可采用捕获引用的方式；如果 lambda 表达式可以超出函数作用域，应采用捕获值的方式。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2011 5.1.2(7)",
        "related": "ID_localAddressFlowOut",
        "reference": "C++ Core Guidelines F.52,C++ Core Guidelines F.53,C++ Core Guidelines F.54"
        },
    "ID_tooManyLambdaLines": {
        "checkPoint": "lambda 表达式的行数应在规定范围之内",
        "level": "warning",
        "comment": "复杂的 lambda 表达式与其调用者的代码混在一起时，是难以阅读的，引入 lambda 表达式的目的应该是“化简”，否则应使用普通函数。",
        "config": {
            "ID_function/maxLambdaLineCount": "行数上限，超过则报出"
            },
        "tag": "function"
        },
    "ID_tooManyLabels": {
        "checkPoint": "函数的标签数量应在规定范围之内",
        "level": "warning",
        "comment": "标签过多意味着函数内部的跳转逻辑过于复杂，违反结构化设计理念，应适当重构。",
        "config": {
            "ID_function/maxLabelCount": "标签数量上限，超过则报出"
            },
        "tag": "function"
        },
    "ID_memoryLeak": {
        "checkPoint": "不可失去对已分配内存的控制",
        "level": "warning",
        "comment": "已分配内存的地址不可被遗失，否则相关内存无法被访问也无法被回收，这种问题称为“内存泄漏（memory leak）”，会导致可用内存被耗尽，使程序无法正确运行。",
        "tag": "resource",
        "related": "ID_resourceLeak,ID_ownerlessResource",
        "reference": "C++ Core Guidelines P.8,C++ Core Guidelines E.13"
    },
    "ID_resourceLeak": {
        "checkPoint": "不可失去对已分配资源的控制",
        "level": "warning",
        "comment": "已分配资源的指针、句柄或描述符等信息不可被遗失，否则相关资源无法被访问也无法被回收，会导致资源耗尽以及死锁等问题，使程序无法正确运行。",
        "tag": "resource",
        "related": "ID_memoryLeak",
        "reference": "C++ Core Guidelines P.8,C++ Core Guidelines E.13"
    },
    "ID_insufficientDelete": {
        "checkPoint": "用 delete 释放数组不可漏写中括号",
        "level": "error",
        "comment": "用 new 分配的数组应该用 delete[] 释放，不可漏写中括号，否则引发标准未定义的错误。",
        "tag": "resource",
        "related": "ID_excessiveDelete",
        "standard": "ISO/IEC 14882:2003 5.3.5(2)-undefined,ISO/IEC 14882:2011 5.3.5(2)-undefined,ISO/IEC 14882:2017 8.3.5(2)-undefined",
        "reference": "C++ Core Guidelines ES.61"
        },
    "ID_excessiveDelete": {
        "checkPoint": "用 delete 释放对象不可多写中括号",
        "level": "error",
        "comment": "用 new 分配的对象应该用 delete 释放，不可用 delete[] 释放，否则引发标准未定义的错误。",
        "tag": "resource",
        "related": "ID_insufficientDelete",
        "standard": "ISO/IEC 14882:2003 5.3.5(2)-undefined,ISO/IEC 14882:2011 5.3.5(2)-undefined,ISO/IEC 14882:2017 8.3.5(2)-undefined",
        "reference": "C++ Core Guidelines ES.61"
        },
    "ID_incompatibleDealloc": {
        "checkPoint": "资源的分配与回收方法应配套使用",
        "level": "error",
        "comment": "不同的分配回收方法属于不同的资源管理体系，如果不配套使用会引发严重错误。",
        "tag": "resource",
        "standard": "ISO/IEC 9899:2011 7.22.3.3(2)-undefined,ISO/IEC 9899:2011 7.22.3.4(3)-undefined",
        "reference": "SEI CERT MEM51-CPP"
        },
    "ID_illAccess": {
        "checkPoint": "不可访问未初始化或已释放的资源",
        "level": "error",
        "comment": "访问未初始化或已释放的资源属于逻辑错误，也会导致标准未定义的行为。",
        "tag": "resource",
        "related": "ID_danglingDeref,ID_localInitialization",
        "standard": "ISO/IEC 9899:2011 7.22.3.3(2)-undefined,ISO/IEC 14882:2011 3.7.4.2(4)-undefined",
        "reference": "SEI CERT FIO46-C"
        },
    "ID_illDealloc": {
        "checkPoint": "在栈上分配的空间以及非动态申请的资源不可被释放",
        "level": "error",
        "comment": "释放在栈上分配的空间以及非动态申请的资源会导致标准未定义的错误。",
        "standard": "ISO/IEC 9899:2011 7.22.3.3(2)-undefined,ISO/IEC 9899:2011 7.22.3.4(3)-undefined,ISO/IEC 14882:2011 3.7.4.2(4)-undefined",
        "tag": "resource",
        "reference": "MISRA C 2012 22.2"
        },
    "ID_doubleFree": {
        "checkPoint": "资源不可被重复释放",
        "level": "error",
        "comment": "重复释放资源属于逻辑错误，也会导致标准未定义的问题。",
        "tag": "resource",
        "standard": "ISO/IEC 9899:2011 7.22.3.3(2)-undefined,ISO/IEC 14882:2011 3.7.4.2(4)-undefined",
        "reference": "CWE-415"
        },
    "ID_invalidNullCheck": {
        "checkPoint": "避免无效的空指针检查",
        "level": "warning",
        "comment": "当指针的值一定不为空时，再对其进行检查是没有意义的，往往意味着逻辑错误。",
        "tag": "pointer",
        "related": "ID_repeatedNullCheck",
        "standard": "ISO/IEC 9899:2011 18.6"
        },
    "ID_repeatedNullCheck": {
        "checkPoint": "不应重复检查指针是否为空",
        "level": "warning",
        "comment": "重复的空指针检查是不必要的，使代码显得繁琐，且干扰编译器优化。",
        "tag": "pointer",
        "related": "ID_invalidNullCheck"
        },
    "ID_copiedFILE": {
        "checkPoint": "标准 FILE 对象不应被复制",
        "level": "warning",
        "comment": "每个文件流只应对应一个 FILE 对象，如果存在多个副本会造成数据不一致的问题。",
        "tag": "resource",
        "standard": "ISO/IEC 9899:1999 7.19.3(6),ISO/IEC 9899:2011 7.21.3(6)",
        "reference": "MISRA C 2012 22.5"
        },
    "ID_arrayIndexOverflow": {
        "checkPoint": "数组下标不可越界",
        "level": "error",
        "comment": "数组下标不在数组声明的大小范围之内，意味着内存读写错误，会导致难以控制的后果。",
        "tag": "buffer",
        "related": "ID_bufferOverflow",
        "reference": "CWE-119,CWE-125,CWE-131,CWE-787,CWE-788,C++ Core Guidelines ES.103,SEI CERT ARR30-C"
        },
    "ID_oddSubscripting": {
        "checkPoint": "数组下标应为整形表达式",
        "level": "warning",
        "comment": "C/C++ 语法规定，在数组取值时，数组下标可以在中括号的右侧也可以在左侧，然而这只是一种理论上的设计，在实际编码中，应采用约定俗成的方式，即数组的名称在中括号的左侧，下标在中括号的右侧。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2003 8.3.4(6),ISO/IEC 14882:2011 8.3.4(6)"
        },        
    "ID_plainSensitiveInfo": {
        "checkPoint": "敏感数据不可写入代码",
        "level": "warning",
        "comment": "代码中的敏感数据极易泄露，产品以及相关运维、测试工具的代码均不可记录任何敏感数据。",
        "tag": "security",
        "related": "ID_secretLeak",
        "reference": "CWE-798,CWE-259,SEI CERT MSC41-C"
        },
    "ID_throwPointer": {
        "checkPoint": "不应将指针作为异常抛出",
        "level": "suggestion",
        "comment": "如果将指针作为异常抛出，并且该指针指向动态创建的对象，会增加不必要的内存管理开销，也容易造成意料之外的错误。",
        "tag": "exception",
        "reference": "MISRA C++ 2008 15-0-2"
        },
    "ID_if_tooManyElseIf": {
        "checkPoint": "if...else-if 分枝数量应在规定范围之内",
        "level": "warning",
        "comment": "if...else-if 分枝超过指定数量，代码较为复杂不利于维护，而且在执行时各分枝的条件需逐一判断，效率较低，建议改为遵循某种算法的索引结构。",
        "config": {
            "ID_if/maxElseIfCount": "分枝数量上限，超过则报出"
            },
        "tag": "control"
        },
    "ID_for_floatCounter": {
        "checkPoint": "for 循环变量不应为浮点型",
        "level": "warning",
        "comment": "用于控制循环次数的变量称为循环变量，这种变量不应采用浮点类型，否则循环的次数难以控制。",
        "tag": "control",
        "related": "ID_illFloatComparison",
        "reference": "MISRA C 2004 13.4,MISRA C 2012 14.1,MISRA C++ 2008 6-5-1"
        },
    "ID_for_counterChangedInBody": {
        "checkPoint": "for 循环变量不应在循环体内被改变",
        "level": "warning",
        "comment": "用于控制循环次数的变量称为循环变量，这种变量只应在 for 迭代声明的第 3 个表达式中被改变，否则陡增逻辑复杂度，且可读性较差。",
        "tag": "control",
        "reference": "C++ Core Guidelines ES.86,MISRA C 2004 13.6,MISRA C++ 2008 6-5-3"
        },
    "ID_for_counterNested": {
        "checkPoint": "嵌套的 for 循环不应使用相同的循环变量",
        "level": "warning",
        "comment": "同一个循环变量在内外层 for 循环中均被修改，使循环次数难以控制，是过于复杂的循环逻辑，也可能是某种错误。",
        "tag": "control",
        "related": "ID_for_counterChangedInBody"
        },
    "ID_for_emptyBlock": {
        "checkPoint": "for 循环体不应为空",
        "level": "warning",
        "comment": "空的 for 循环将逻辑功能全部压缩到了迭代表达式中，可读性较差。",
        "tag": "control",
        "reference": "C++ Core Guidelines ES.85"
        },
    "ID_switch_caseOutOfRange": {
        "checkPoint": "case 常量的范围不可超出 switch 变量的范围",
        "level": "warning",
        "comment": "如果 case 常量的范围超出了 switch 变量的范围，会导致相应分枝永远不会被执行。",
        "tag": "control",
        "related": "ID_illComparison",
        "reference": "CWE-561"
        },
    "ID_switch_uselessFallThrough": {
        "checkPoint": "不应存在紧邻 default 标签的空 case 标签",
        "level": "warning",
        "comment": "紧邻 default 标签的空 case 标签是没有意义的，应当去除。",
        "tag": "control"
        },
    "ID_switch_onlyDefault": {
        "checkPoint": "switch 语句不应只包含 default 标签",
        "level": "warning",
        "comment": "只有 default 标签的 switch 语句是没有意义的，起不到分枝选择的作用，往往是残留代码或功能未实现。",
        "tag": "control",
        "reference": "MISRA C 2012 16.6"
        },
    "ID_switch_onlyOneCase": {
        "checkPoint": "switch 语句不应只包含一个 case 标签",
        "level": "warning",
        "comment": "只有一个 case 标签的 switch 语句与 if 语句语义相同，但形式上更为复杂，应改为 if 语句。",
        "tag": "control",
        "reference": "MISRA C 2012 16.6"
        },
    "ID_switch_tooManyCases": {
        "checkPoint": "switch 语句分枝数量应在规定范围之内",
        "level": "warning",
        "comment": "switch 语句分枝过多会使代码过于庞大不利于维护，分枝很多时建议将每个 case 的执行逻辑抽取成函数，再按遵循某种算法的索引结构组织在一起。",
        "config": {
            "ID_switch/maxCasesCount": "分枝数量上限，超过则报出"
            },
        "tag": "control"
        },
    "ID_switch_brace": {
        "checkPoint": "switch 语句应该用大括号括起来",
        "level": "suggestion",
        "comment": "switch 语句应为包含多条语句的复合语句，且用大括号括起来，否则不应选用 switch 语句。",
        "tag": "control",
        "related": "ID_if_brace,ID_switch_onlyDefault,ID_switch_onlyOneCase",
        "reference": "MISRA C 2004 14.8,MISRA C 2012 15.6,MISRA C++ 2008 6-3-1"
        },
    "ID_switch_forbidNest": {
        "checkPoint": "switch 语句不应嵌套",
        "level": "suggestion",
        "comment": "嵌套的 switch 语句使代码显得复杂，不利于维护。",
        "tag": "control"
        },
    "ID_try_disorderedHandlers": {
        "checkPoint": "catch 块序列中针对派生类的应排在前面，针对基类的应排在后面",
        "level": "error",
        "comment": "catch 块序列中针对派生类的应排在前面，针对基类的应排在后面，如果违反这个顺序，针对派生类的 catch 块将失去作用。",
        "tag": "control",
        "standard": "ISO/IEC 14882:2003 15.3,ISO/IEC 14882:2011 15.3,ISO/IEC 14882:2011 18.3",
        "reference": "CWE-561,C++ Core Guidelines E.31"
        },
    "ID_try_disorderedEllipsis": {
        "checkPoint": "catch 块序列中 catch-all 块（ellipsis handler）应位于最后",
        "level": "error",
        "comment": "catch 块序列中 catch-all 块（ellipsis handler）应位于最后，否则其后的 catch 块将失去作用。",
        "tag": "control",
        "standard": "ISO/IEC 14882:2003 15.3(6),ISO/IEC 14882:2011 15.3(5),ISO/IEC 14882:2011 18.3(5)",
        "reference": "CWE-561,C++ Core Guidelines E.31,MISRA C++ 2008 15-3-7"
        },
    "ID_try_forbidNest": {
        "checkPoint": "try 块不应嵌套",
        "level": "suggestion",
        "comment": "嵌套的 try-catch 使代码显得复杂，不利于维护。",
        "tag": "control",
        "reference": "C++ Core Guidelines E.17"
        },
    "ID_catch_value": {
        "checkPoint": "通过引用捕获异常",
        "level": "warning",
        "comment": "如果按传值的方式捕获异常会造成不必要的复制开销，也可能产生对象切片问题；如果通过指针捕获异常，会增加不必要的内存管理开销，通过引用捕获异常才是合理的方式。",
        "tag": "control",
        "related": "ID_catch_slicing,ID_throwPointer",
        "reference": "C++ Core Guidelines E.15,C++ Core Guidelines ES.63,MISRA C++ 2008 15-3-5"
        },
    "ID_catch_slicing": {
        "checkPoint": "捕获异常时不应产生对象切片问题",
        "level": "warning",
        "comment": "如果catch块的参数是多态类的对象，则会产生对象切片问题，造成对异常的错误处理，故参数应改为对象的引用。",
        "tag": "control",
        "related": "ID_catch_value,ID_objectSlicing",
        "reference": "C++ Core Guidelines C.145,C++ Core Guidelines ES.63"
        },
    "ID_catch_generic": {
        "checkPoint": "不应捕获过于宽泛的异常",
        "level": "warning",
        "comment": "捕获过于宽泛的异常如 std::exception、std::logic_error、std::runtime_error 等，使异常处理失去针对性，无法做到具体问题具体处理，而且很可能将本不应处理的异常一并捕获，造成混乱。",
        "tag": "control",
        "related": "ID_throwGenericException",
        "reference": "CWE-396"
        },
    "ID_catch_nonExceptionType": {
        "checkPoint": "不应捕获非异常类型",
        "level": "warning",
        "comment": "字符串或变量以及非异常相关的对象不应被当作异常捕获，否则意味着异常相关的设计是不健全的。",
        "tag": "control",
        "related": "ID_throwNonExceptionType",
        "reference": "C++ Core Guidelines E.14"
        },
    "ID_catch_justRethrow": {
        "checkPoint": "捕获异常后不应直接重新抛出异常，需对异常进行有效处理",
        "level": "warning",
        "comment": "捕获异常后将其直接重新抛出是没有意义的，还会造成不必要的开销。",
        "tag": "control"
        },
    "ID_missingDestructor": {
        "checkPoint": "存在拷贝构造函数或赋值运算符时，不应缺少析构函数",
        "level": "warning",
        "comment": "存在拷贝构造函数或赋值运算符时，不应缺少析构函数。",
        "tag": "type",
        "related": "ID_missingCopyConstructor,ID_missingCopyAssignOperator",
        "reference": "C++ Core Guidelines C.21,C++ Core Guidelines C.30,C++ Core Guidelines C.33"
        },
    "ID_missingCopyConstructor": {
        "checkPoint": "存在赋值运算符或析构函数时，不应缺少拷贝构造函数",
        "level": "warning",
        "comment": "存在赋值运算符或析构函数时，不应缺少拷贝构造函数。",
        "tag": "type",
        "related": "ID_missingDestructor,ID_missingCopyAssignOperator",
        "reference": "C++ Core Guidelines C.21"
        },
    "ID_missingMoveConstructor": {
        "checkPoint": "存在移动赋值运算符时，不应缺少移动构造函数",
        "level": "warning",
        "comment": "存在移动赋值运算符，不应缺少移动构造函数，详见“Rule of five”。",
        "tag": "type",
        "related": "ID_missingCopyConstructor",
        "reference": "C++ Core Guidelines C.21"
        },
    "ID_missingCopyAssignOperator": {
        "checkPoint": "存在拷贝构造函数或析构函数时，不应缺少拷贝赋值运算符",
        "level": "warning",
        "comment": "存在拷贝构造函数或析构函数时，不应缺少拷贝赋值运算符。",
        "tag": "type",
        "related": "ID_missingDestructor,ID_missingCopyConstructor",
        "reference": "C++ Core Guidelines C.21"
        },
    "ID_missingMoveAssignOperator": {
        "checkPoint": "存在移动构造函数时，不应缺少移动赋值运算符",
        "level": "warning",
        "comment": "存在移动构造函数时，不应缺少移动赋值运算符，详见“Rule of five”。",
        "tag": "type",
        "related": "ID_missingCopyAssignOperator",
        "reference": "C++ Core Guidelines C.21"
        },
    "ID_missingExplicitConstructor": {
        "checkPoint": "可接受一个参数的构造函数需用 explicit 关键字限定",
        "level": "suggestion",
        "comment": "为了避免意料之外的类型转换，可接受一个参数的构造函数应该用 explicit 关键字限定。",
        "tag": "type",
        "related": "ID_missingExplicitConvertor",
        "reference": "C++ Core Guidelines C.46,MISRA C++ 2008 12-1-3"
        },
    "ID_missingExplicitConvertor": {
        "checkPoint": "重载的类型转换运算符需用 explicit 关键字限定",
        "level": "suggestion",
        "comment": "为了避免意料之外的类型转换，重载的类型转换运算符需用 explicit 关键字限定。",
        "tag": "type",
        "related": "ID_missingExplicitConstructor",
        "reference": "C++ Core Guidelines C.164"
        },
    "ID_unsuitableCopyAssignOperator": {
        "checkPoint": "抽象类禁用拷贝赋值运算符",
        "level": "warning",
        "comment": "抽象类没有独立的对象，不应存在拷贝赋值运算符，否则赋值是不完整的。",
        "tag": "type",
        "reference": "MISRA C++ 2008 12-8-2,C++ Core Guidelines C.67"
        },
    "ID_excessiveExplicit": {
        "checkPoint": "不应过度使用 explicit 关键字",
        "level": "warning",
        "comment": "对类的拷贝、移动以及不接受 1 个参数的构造函数一般不用 explicit 限定，否则有损代码的易用性和可扩展性。",
        "tag": "type",
        "reference": "C++ Core Guidelines C.46"
        },
    "ID_tooManyFields": {
        "checkPoint": "数据成员的数量应在规定范围之内",
        "level": "warning",
        "comment": "类或联合体的数据成员过多意味着一个逻辑或功能单位承担了过多的职责，违反了模块化设计理念，是难以维护的。",
        "config": {
            "ID_class/maxFieldsCount": "类数据成员的数量上限，超过则报出",
            "ID_union/maxFieldsCount": "联合体数据成员的数量上限，超过则报出"
            },
        "tag": "type"
        },
    "ID_plainNumericChar": {
        "checkPoint": "参与数值运算的 char 变量需显式声明 signed 或 unsigned",
        "level": "warning",
        "comment": "没有 signed 或 unsigned 限制的 char 类型，是否有符号由具体的编译器决定。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 3.9.1(1)-implementation,ISO/IEC 14882:2011 3.9.1(1)-implementation",
        "reference": "MISRA C++ 2008 5-0-11,SEI CERT INT07-C"
        },
    "ID_plainBinaryChar": {
        "checkPoint": "字节的类型应为 unsigned char",
        "level": "warning",
        "comment": "字节等二进制概念不应受符号位干扰，应声明为 unsigned char。",
        "tag": "declaration",
        "related": "ID_plainNumericChar,ID_bitwiseOperOnSigned",
        "standard": "ISO/IEC 14882:2003 3.9.1(1)-implementation,ISO/IEC 14882:2011 3.9.1(1)-implementation"
        },
    "ID_uselessQualifier": {
        "checkPoint": "枚举类型的底层类型不应为 const 或 volatile",
        "level": "warning",
        "comment": "将 enum 或 enum class 的底层类型（underlying type）设为 const 或 volatile 是没有意义的，会被编译器忽略，为语言用法错误。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2011 7.2(2),ISO/IEC 14882:2011 10.2(2)"
        },
    "ID_duplicateEnumerator": {
        "checkPoint": "同类枚举项的值不应相同",
        "level": "warning",
        "comment": "枚举项用于标记不同的事物，名称不同但值相同的枚举项往往意味着错误。",
        "tag": "type",
        "reference": "C++ Core Guidelines Enum.8"
    },
    "ID_casualInitialization": {
        "checkPoint": "合理初始化各枚举项",
        "level": "suggestion",
        "comment": "合理初始化各枚举项。",
        "tag": "type",
        "related": "ID_duplicateEnumerator",
        "reference": "MISRA C 2004 9.3,MISRA C++ 2008 8-5-3"
        },
    "ID_forbidUnscopedEnum": {
        "checkPoint": "用 enum class 取代 enum",
        "level": "suggestion",
        "comment": "传统C枚举没有有效的类型和作用域控制，极易造成类型混淆和名称冲突，在 C++ 语言中建议改用 enum class。",
        "tag": "type",
        "standard": "ISO/IEC 14882:2011 7.2(2)",
        "reference": "C++ Core Guidelines Enum.3"
        },
    "ID_forbidUnnamedEnum": {
        "checkPoint": "不应使用匿名枚举声明",
        "level": "suggestion",
        "comment": "匿名枚举声明相当于在当前作用域定义常量，类型不够明确，而且如果无法确定枚举类型的名称，也意味着各枚举项不应聚为一类。",
        "tag": "type",
        "reference": "C++ Core Guidelines Enum.6"
        },
    "ID_forbidNonBasicField": {
        "checkPoint": "联合体内禁用非基本类型的对象",
        "level": "warning",
        "comment": "因为联合体成员之间共享内存地址，所以成员具有构造或析构函数时会导致混乱。",
        "tag": "type",
        "standard": "ISO/IEC 14882:1998 9.5(1),ISO/IEC 14882:2003 9.5(1),ISO/IEC 14882:2011 9.5(2 3 4)"
        },
    "ID_forbidNakedUnion": {
        "checkPoint": "禁用在类之外定义的联合体",
        "level": "suggestion",
        "comment": "联合体各成员共享存储地址，易引发意料之外的错误。如果一定要使用联合体，需对其进行一定的封装，避免对成员的错误访问。",
        "tag": "type",
        "related": "ID_forbidUnion",
        "reference": "C++ Core Guidelines C.181,MISRA C 2004 18.4,MISRA C 2012 19.2,MISRA C++ 2008 9-5-1"
        },
    "ID_forbidUnion": {
        "checkPoint": "禁用联合体",
        "level": "suggestion",
        "comment": "联合体各成员共享存储地址，是一种对类型理念的破坏。",
        "tag": "type",
        "related": "ID_forbidNakedUnion",
        "reference": "MISRA C 2004 18.4,MISRA C 2012 19.2,MISRA C++ 2008 9-5-1"
        },
    "ID_deprecatedDefaultArgument": {
        "checkPoint": "不建议虚函数的参数有默认值",
        "level": "suggestion",
        "comment": "虚函数参数的默认值不受多态规则控制，通过基类指针或引用调用派生类重写的虚函数时，默认值仍采用基类中的定义，易造成混淆，建议虚函数参数不使用默认值。",
        "tag": "declaration",
        "related": "ID_inconsistentDefaultArgument",
        "standard": "ISO/IEC 14882:2003 8.3.6(10),ISO/IEC 14882:2011 8.3.6(10),ISO/IEC 14882:2017 11.3.6(10)",
        "reference": "CWE-628,C++ Core Guidelines C.140,MISRA C++ 2008 8-3-1"
        },
    "ID_inconsistentDefaultArgument": {
        "checkPoint": "虚函数参数的默认值应与基类中声明的一致",
        "level": "error",
        "comment": "虚函数参数的默认值不受多态规则控制，通过基类指针或引用调用派生类重写的虚函数时，默认值仍采用基类中的定义。",
        "tag": "declaration",
        "related": "ID_deprecatedDefaultArgument",
        "standard": "ISO/IEC 14882:2003 8.3.6(10),ISO/IEC 14882:2011 8.3.6(10),ISO/IEC 14882:2017 11.3.6(10)",
        "reference": "CWE-628,C++ Core Guidelines C.140,MISRA C++ 2008 8-3-1"
        },
    "ID_complexDeclaration": {
        "checkPoint": "不建议采用复杂的声明",
        "level": "suggestion",
        "comment": "复杂的声明可读性较差，容易造成理解上的偏差。",
        "tag": "declaration"
        },
    "ID_staticNotUsed": {
        "checkPoint": "不应存在未被使用的本地 static 函数",
        "level": "warning",
        "comment": "未被使用的本地 static 函数得不到任何执行机会，应删除或修正调用关系。",
        "tag": "declaration",
        "related": "ID_unreachableCode",
        "reference": "MISRA C++ 2008 0-1-10"
        },
    "ID_privateNotUsed": {
        "checkPoint": "不应存在未被使用的 private 成员",
        "level": "warning",
        "comment": "未被使用的 private 成员没有意义，应删除或修正引用关系。",
        "tag": "declaration",
        "related": "ID_unreachableCode",
        "reference": "MISRA C++ 2008 0-1-10"
        },
    "ID_missingParamName": {
        "checkPoint": "函数原型声明中的参数应具有合理的名称",
        "level": "suggestion",
        "comment": "参数的名称是其用途的直接说明，合理的名称可显著提高可读性。",
        "tag": "declaration",
        "reference": "MISRA C 2004 16.3,MISRA C 2012 8.2"
        },
    "ID_deprecatedAutoPtr": {
        "checkPoint": "避免使用 std::auto_ptr",
        "level": "warning",
        "comment": "std::auto_ptr 在 C++11 标准中已被废弃，应使用 std::unique_ptr。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2011 D.10-deprecated",
        "reference": "C++ Core Guidelines R.20"
        },
    "ID_mixedDeclarations": {
        "checkPoint": "不应将函数或函数指针和其他声明写在同一个语句中",
        "level": "suggestion",
        "comment": "每条语句只应声明一个函数或函数指针，否则可读性较差。",
        "tag": "declaration",
        "related": "ID_tooManyDeclarators",
        "reference": "C++ Core Guidelines ES.10"
        },
    "ID_mixedTypeObjDefinition": {
        "checkPoint": "不建议将类型定义和对象声明写在一个语句中",
        "level": "suggestion",
        "comment": "将类型定义和对象声明写在一个语句中可读性较差。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines C.7"
        },
    "ID_tooManyDeclarators": {
        "checkPoint": "在一个语句中不应声明过多对象或函数",
        "level": "suggestion",
        "comment": "在一个语句中不应声明过多对象或函数，建议在每个语句中只声明一个对象或函数，提高可读性也可减少笔误。",
        "config": {
            "ID_declaration/maxDeclaratorCount": "一个声明语句能包含的对象个数上限，超过则报出"
            },
        "tag": "declaration",
        "reference": "C++ Core Guidelines ES.10,MISRA C++ 2008 8-0-1"
        },
    "ID_sandwichedModifier": {
        "checkPoint": "const、volatile 等关键字不应出现在基本类型名称的中间",
        "level": "suggestion",
        "comment": "某些基本类型可由多个符号组成，const 或 volatile 等关键字不应出现在这些符号的中间，否则可读性较差。",
        "tag": "declaration",
        "related": "ID_badQualifierPosition,ID_badSpecifierPosition",
        "reference": "C++ Core Guidelines NL.26"
    },
    "ID_badQualifierPosition": {
        "checkPoint": "const、volatile 限定类型时应出现在左侧",
        "level": "suggestion",
        "comment": "语言允许 const、volatile 出现在类型名的左侧，也可以出现在其右侧，甚至可以出现在基本类型名的中间，为了提高可读性，应对其位置进行统一规范。",
        "tag": "declaration",
        "related": "ID_sandwichedModifier,ID_badSpecifierPosition",
        "reference": "C++ Core Guidelines NL.26"
        },
    "ID_badSpecifierPosition": {
        "checkPoint": "inline、virtual、static、typedef 等关键字应出现在类型名的左侧",
        "level": "suggestion",
        "comment": "语言允许 inline、virtual、static、typedef 等关键字可以出现在类型名的左侧，也可以出现在其右侧，甚至可以出现在基本类型名的中间，为了提高可读性，应对其位置进行统一规范。",
        "tag": "declaration",
        "related": "ID_sandwichedModifier,ID_badQualifierPosition"
        },
    "ID_hideLocal": {
        "checkPoint": "局部名称不应被覆盖",
        "level": "warning",
        "comment": "嵌套的作用域中不应出现相同的名称，否则干扰阅读，极易产生误解。",
        "tag": "declaration",
        "reference": "CWE-1109,C++ Core Guidelines ES.12,MISRA C 2004 5.2,MISRA C 2012 5.3,MISRA C++ 2008 2-10-2"
        },
    "ID_hideMember": {
        "checkPoint": "成员名称不应被覆盖",
        "level": "warning",
        "comment": "如果成员函数内的局部名称与成员名称相同，会干扰阅读，易产生误解。",
        "tag": "declaration",
        "reference": "CWE-1109,MISRA C 2004 5.2,MISRA C 2012 5.3,MISRA C++ 2008 2-10-2"
        },
    "ID_missingConst": {
        "checkPoint": "避免用常量字符串对非常量字符串指针赋值",
        "level": "warning",
        "comment": "用常量字符串对非常量字符串指针赋值，相关内存被修改会导致标准未定义的问题。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 2.13.4(2)-undefined,ISO/IEC 14882:2011 2.14.5(12)-undefined,ISO/IEC 14882:2011 5.13.5(16)-undefined",
        "reference": "MISRA C 2012 7.4"
        },
    "ID_virtualComparison": {
        "checkPoint": "比较运算符不应为虚函数",
        "level": "warning",
        "comment": "重载的比较运算符很难正确触发 C++ 的多态机制，将其设为虚函数很可能引发意料之外的错误。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines C.87"
        },
    "ID_virtualAssignment": {
        "checkPoint": "拷贝赋值、移动赋值运算符不应为虚函数",
        "level": "warning",
        "comment": "拷贝或移动赋值运算符的返回类型应为所属类的非 const 引用，这类运算符即使是虚函数也不便于被重写。",
        "tag": "declaration",
        "related": "ID_nonStdAssignmentRetType",
        "reference": "C++ Core Guidelines C.60,C++ Core Guidelines C.63"
        },
    "ID_nonStdCopyAssignmentParam": {
        "checkPoint": "拷贝赋值运算符的参数应为同类对象的 const 左值引用",
        "level": "warning",
        "comment": "拷贝赋值运算符的参数不应按值传递，否则会造成不必要的复制，以及“对象切片”等问题。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines C.60"
    },
    "ID_nonStdMoveAssignmentParam": {
        "checkPoint": "移动赋值运算符的参数应为同类对象的非 const 右值引用",
        "level": "warning",
        "comment": "移动赋值运算符的参数不可为 const 右值引用，否则将失去移动赋值的意义。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines C.63"
    },
    "ID_nonStdAssignmentRetType": {
        "checkPoint": "拷贝赋值、移动赋值运算符应返回所属类的非 const 引用",
        "level": "warning",
        "comment": "按赋值表达式的标准语法要求，以及 C++ 语言的惯例，拷贝赋值、移动赋值应返回所属类的非 const 引用，便于调用者使用并满足泛型编程的要求。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines F.47,C++ Core Guidelines C.60,C++ Core Guidelines C.63"
    },
    "ID_mainReturnsNonInt": {
        "checkPoint": "main 函数的返回类型只应为 int",
        "level": "warning",
        "comment": "main 函数的返回值可作为整个进程执行情况的总结，按惯例返回 0 或 EXIT_SUCCESS 表示执行成功，非 0 或 EXIT_FAILURE 表示执行失败，main 函数的返回值会作为标准 exit 函数的参数。",
        "tag": "function",
        "standard": "ISO/IEC 9899:1999 5.1.2.2.1(1) 5.1.2.2.3(1),ISO/IEC 9899:2011 5.1.2.2.1(1) 5.1.2.2.3(1)",
        "reference": "C++ Core Guidelines F.46"
        },
    "ID_missingNamespace": {
        "checkPoint": "为代码设定合理的命名空间",
        "level": "warning",
        "comment": "命名空间是 C++ 项目的必要组成结构，可有效规避名称冲突等问题。",
        "tag": "global",
        "related": "ID_usingNamespaceInHeader,ID_forbidUsingDirectives",
        "reference": "MISRA C++ 2008 7-3-1"
        },
    "ID_nonGlobalMain": {
        "checkPoint": "main 函数只应处于全局作用域中",
        "level": "warning",
        "comment": "main 函数作为程序的入口是一个特殊的函数，链接器需要对其特殊处理，不应受命名空间等作用域的限制。",
        "tag": "global",
        "reference": "MISRA C++ 2008 7-3-2"
        },
    "ID_illFormedMain": {
        "checkPoint": "main 函数不应被重载，也不应声明为 inline、static 或 constexpr",
        "level": "warning",
        "comment": "main 函数作为程序的入口是一个特殊的函数，链接器需要对其特殊处理，标准规定 main 函数不应被重载，也不应声明为 inline、static 或 constexpr。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2003 3.6.1(2 3),ISO/IEC 14882:2011 3.6.1(2 3),ISO/IEC 14882:2017 6.6.1(2 3)"
        },
    "ID_constLiteralReference": {
        "checkPoint": "对常量的定义不应为引用",
        "level": "warning",
        "comment": "虽然 C++ 语言十分灵活，可以通过多种方式达到同一种目的，但应该选择最简洁且通俗易懂的方式实现。",
        "tag": "declaration"
        },
    "ID_forbidEnumBitfield": {
        "checkPoint": "不应对枚举变量声明位域",
        "level": "warning",
        "comment": "枚举变量的类型可以是有符号整数，符号位与位域结合易导致意料之外的错误，且不利于枚举类型的扩展。",
        "tag": "declaration",
        "related": "ID_singleSignedBitfield",
        "reference": "MISRA C++ 2008 9-6-3"
        },
    "ID_forbidFlexibleArray": {
        "checkPoint": "禁用柔性数组",
        "level": "suggestion",
        "comment": "柔性数组（flexible array）一般是指结构体最后不完整定义的数组成员，表示不占用空间的指针，这种数组在 C99 中有所定义，但不在 C++ 标准之中，在 C++ 代码中不应使用。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.7.2.1(16)",
        "reference": "MISRA C 2012 18.7"
        },
    "ID_unsuitableArraySize": {
        "checkPoint": "局部数组的长度不应过大",
        "level": "warning",
        "comment": "局部数组的长度过大增加函数堆栈的压力，易导致溢出错误。",
        "config": {
            "ID_declaration/maxLocalArraySize": "局部数组的长度上限，超过则报出"
            },
        "tag": "declaration",
        "reference": "CWE-770,SEI CERT MEM05-C"
        },
    "ID_exceededBitfield": {
        "checkPoint": "位域长度不应超过类型约定的大小",
        "level": "warning",
        "comment": "位域长度不应超过类型约定的大小，否则没有意义且会造成不必要的空间浪费，出现这种问题往往意味着设计上的错误。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:2011 6.7.2.1(4),ISO/IEC 14882:2011 9.6(1)"
        },
    "ID_singleSignedBitfield": {
        "checkPoint": "有符号变量的位域长度不应为 1",
        "level": "warning",
        "comment": "有符号变量的位域长度如果为 1 表示只有一个比特位，而该比特位是符号位，极易造成意料之外的错误。",
        "tag": "declaration",
        "reference": "MISRA C++ 2008 9-6-4"
        },
    "ID_invalidFinal": {
        "checkPoint": "不应将 union 设为 final",
        "level": "warning",
        "comment": "标准规定 union 不可作为基类，所以将 union 声明为 final 是没有意义的，为语言运用错误。",
        "standard": "ISO/IEC 9899:2011 9.5(2)",
        "tag": "declaration"
        },
    "ID_virtualInFinal": {
        "checkPoint": "final 类中不应声明虚函数",
        "level": "warning",
        "comment": "final 类不再产生派生类，其中的虚函数也不会再被重写，故不应声明虚函数。",
        "standard": "ISO/IEC 9899:2011 9(3)",
        "tag": "declaration"
        },
    "ID_exceptionUnsafe": {
        "checkPoint": "确保异常的安全性",
        "level": "warning",
        "comment": "确保异常的安全性。",
        "tag": "exception",
        "related": "ID_resourceLeak,ID_ownerlessResource,ID_throwInSwap",
        "reference": "Effective C++ item 29"
        },
    "ID_exceptionInException": {
        "checkPoint": "异常类的构造函数与异常信息相关的函数不应抛出异常",
        "level": "warning",
        "comment": "抛出异常时，或获取异常相关的信息时，如果再抛出异常不利于异常的处理与定位。",
        "tag": "exception",
        "standard": "ISO/IEC 14882:2011 18.8.1"
        },
    "ID_forbidThrowSpecification": {
        "checkPoint": "禁用含 throw 关键字的异常规格说明",
        "level": "warning",
        "comment": "由 throw 关键字声明的动态异常规格说明已过时，应采用由 noexcept 关键字声明的方式。",
        "config": {
            "ID_declaration/forbidEmptyThrowSpecification": "为 true 时报出空 throw 异常规格说明，否则放过"
            },
        "tag": "exception",
        "standard": "ISO/IEC 14882:2011 D.4-deprecated,ISO/IEC 14882:2017 D.3-deprecated",
        "reference": "C++ Core Guidelines E.12,C++ Core Guidelines E.30"
        },
    "ID_forbidVariadicFunction": {
        "checkPoint": "禁用可变参数列表",
        "level": "warning",
        "comment": "可变参数列表对参数的类型和数量缺乏有效的限定和控制，是公认的不安全因素。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines ES.34,C++ Core Guidelines F.55,MISRA C 2004 16.1,MISRA C++ 2008 8-4-1"
        },
    "ID_redundantVirtual": {
        "checkPoint": "有 override 或 final 关键字时，不应再出现 virtual 关键字",
        "level": "suggestion",
        "comment": "只应在定义新的虚函数时使用 virtual 关键字，当重写虚函数时，应使用 override 或 final 关键字，不应再出现 virtual 关键字，使代码更清晰简洁。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines C.128"
        },
    "ID_redundantOverride": {
        "checkPoint": "override 和 final 关键字不应同时出现",
        "level": "suggestion",
        "comment": "final 关键字表示不可重写的重写，override 表示可再次重写的重写，出现 final 关键字时不应再出现 override 关键字，使代码更清晰简洁。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines C.128"
        },
    "ID_forbidBitfield": {
        "checkPoint": "禁用位域",
        "level": "suggestion",
        "comment": "引入位域的本意是为了节省空间，然而位域改变了变量约定俗成的取值范围，易造成理解上的偏差，也会造成维护困难。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 9.6(1)-implementation,ISO/IEC 14882:2003 9.6(3),ISO/IEC 14882:2011 9.6(1)-implementation,ISO/IEC 14882:2011 9.6(3),ISO/IEC 14882:2017 12.2.4(1)-implementation,ISO/IEC 14882:2017 12.2.4(3)",
        "related": "ID_exceededBitfield,ID_singleSignedBitfield,ID_forbidEnumBitfield"
        },
    "ID_labelNotUsed": {
        "checkPoint": "不应存在没有用到的标签",
        "level": "warning",
        "comment": "没有用到的标签意味着 goto 语句的缺失，也可能是残留代码，应当去除。",
        "tag": "declaration",
        "reference": "MISRA C 2012 2.6"
        },
    "ID_forbidRestrictPtr": {
        "checkPoint": "禁用 restrict 指针",
        "level": "warning",
        "comment": "C 语言中的 restrict 指针要求其他指针不能再指向相同区域，有助于编译器优化，但不符合这种限制时会导致标准未定义的错误，相当于增加了误用的风险，也提高了测试成本。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.7.3.1(4 9 11)-undefined,ISO/IEC 9899:2011 6.7.3.1(4 9 11)-undefined",
        "reference": "MISRA C 2012 8.14,SEI CERT EXP43-C"
        },
    "ID_forbidStaticArrSize": {
        "checkPoint": "声明数组参数的大小时禁用 static 关键字",
        "level": "warning",
        "comment": "C 语言规定数组作为形式参数时，可用 static 关键字修饰大小，要求传入数组的大小不能小于由 static 关键字修饰的值，这种机制有助于编译器优化，但不符合这种限制时会导致标准未定义错误，相当于增加了误用的风险，也提高了测试成本。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.7.6.3(7),ISO/IEC 9899:2011 6.7.6.3(7)",
        "reference": "MISRA C 2012 17.6"
        },
    "ID_forbidGotoBlocks": {
        "checkPoint": "禁止 goto 语句向嵌套的或无包含关系的作用域跳转",
        "level": "warning",
        "comment": "不同的作用域往往对应不同的条件约束，在不同的作用域间跳转是对约束的破坏，很容易导致逻辑混乱。",
        "tag": "function",
        "related": "ID_forbidGotoBack,ID_forbidGoto",
        "reference": "MISRA C 2012 15.3,MISRA C++ 2008 6-6-1"
        },
    "ID_forbidGotoBack": {
        "checkPoint": "禁止 goto 语句向前跳转",
        "level": "suggestion",
        "comment": "向先于当前 goto 语句定义的标签跳转，可读性较差，是公认的不良实现。",
        "tag": "function",
        "related": "ID_forbidGotoBlocks,ID_forbidGoto",
        "reference": "MISRA C 2012 15.2,MISRA C++ 2008 6-6-2"
        },
    "ID_forbidGoto": {
        "checkPoint": "禁用 goto 语句",
        "level": "suggestion",
        "comment": "历史表明，goto 语句会破坏程序的结构性规划，很容易导致逻辑混乱且不利于维护，在非自动生成的、对可读性有要求的代码中，建议禁用 goto 语句。",
        "tag": "function",
        "related": "ID_forbidGotoBlocks,ID_forbidGotoBack",
        "reference": "C++ Core Guidelines ES.76,MISRA C 2012 15.1"
        },
    "ID_forbidAbsPathInHeaderName": {
        "checkPoint": "include 指令中不应使用绝对路径",
        "level": "warning",
        "comment": "绝对路径使代码过分依赖编译环境，意味着项目的编译设置不完善，应使用相对路径。",
        "tag": "precompile"
        },
    "ID_nonStandardCharInHeaderName": {
        "checkPoint": "字母、数字、下划线以及点号之外的字符不应出现在头文件名称中",
        "level": "warning",
        "comment": "字母、数字、下划线以及点号之外的字符可能与文件系统造成冲突，也可能导致标准之外的问题，所以不应出现在头文件名称中。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.4.7(3)-undefined,ISO/IEC 9899:2011 6.4.7(3)-undefined,ISO/IEC 14882:2003 2.8(2)-undefined,ISO/IEC 14882:2011 2.9(2)-implementation",
        "reference": "MISRA C 2004 19.2,MISRA C 2012 20.2,MISRA C++ 2008 16-2-4"
        },
    "ID_forbidBackslashInHeaderName": {
        "checkPoint": "include 指令中不应使用反斜杠",
        "level": "warning",
        "comment": "在 include 指令的尖括号或引号之间使用反斜杠不利于代码移植，而且可能会导致标准之外的问题。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.4.7(3)-undefined,ISO/IEC 9899:2011 6.4.7(3)-undefined,ISO/IEC 14882:2003 2.8(2)-undefined,ISO/IEC 14882:2011 2.9(2)-implementation",
        "reference": "MISRA C++ 2008 16-2-5"
        },
    "ID_forbidCHeaderInCpp": {
        "checkPoint": "C++ 代码不应引用 C 头文件",
        "level": "warning",
        "comment": "在 C++ 语言中应使用 C++ 标准头文件，stdio.h、stdlib.h 等 C 语言头文件不在 C++ 标准之内，应改用 cstdio、cstdlib 等符合 C++ 标准的头文件。",
        "tag": "precompile",
        "standard": "ISO/IEC 14882:2003 D.5,ISO/IEC 14882:2011 D.5,ISO/IEC 14882:2017 D.5",
        "reference": "MISRA C++ 2008 18-0-1"
        },
    "ID_forbiddenHeader": {
        "checkPoint": "禁用不合规的头文件",
        "level": "warning",
        "comment": "无意义的，行为不明确的或有不良副作用的头文件应禁用。",
        "config": { "//": "详见说明" },
        "tag": "precompile",
        "standard": "ISO/IEC 14882:2017 C.5.1(4)",
        "reference": "MISRA C 2012 21.5,MISRA C 2012 21.10,MISRA C 2012 21.11,MISRA C 2012 21.12,MISRA C++ 2008 18-7-1,MISRA C++ 2008 18-0-4,MISRA C++ 2008 27-0-1"
        },
    "ID_spaceStyle": {
        "checkPoint": "空格应遵循统一风格",
        "level": "suggestion",
        "comment": "与缩进、运算符、关键字有关的空格应遵循统一风格，过于随意的空格会对阅读产生较大干扰，甚至形成笔误。",
        "tag": "style",
        "related": "ID_stickyAssignmentOperator"
        },
    "ID_braceStyle": {
        "checkPoint": "大括号应遵循统一风格",
        "level": "suggestion",
        "comment": "大括号应遵循统一风格。",
        "tag": "style"
        },
    "ID_returnSuperfluousConst": {
        "checkPoint": "基本类型的返回值不应使用 const 修饰",
        "level": "warning",
        "comment": "基本类型（char、int、long 等）的返回值本来就不能作为可修改的左值，const 修饰符是多余的。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2003 3.10(5),ISO/IEC 14882:2011 3.10(1)"
        },
    "ID_nonPODFilling": {
        "checkPoint": "memset 等函数不应作用于带有虚函数的对象",
        "level": "error",
        "comment": "memset、memcpy、memmove 等具有填充功能的函数不应作用于带有虚函数的对象，否则会破坏其虚函数表等结构。",
        "tag": "buffer",
        "reference": "CWE-463,C++ Core Guidelines SL.con.4,C++ Core Guidelines C.90"
        },
    "ID_missingHeaderGuard": {
        "checkPoint": "头文件不应缺少守卫",
        "level": "warning",
        "comment": "以 .h 或 .hpp 为扩展名的头文件应包含头文件守卫。",
        "config": {
            "ID_missingHeaderGuard/allowPragmaOnce": "为 true 时 #pragma once 也可作为符合要求的头文件守卫"
            },
        "tag": "precompile",
        "reference": "C++ Core Guidelines SF.8,MISRA C 2004 19.15,MISRA C++ 2008 16-2-3"
        },
    "ID_evalOverflow": {
        "checkPoint": "运算结果不应溢出",
        "level": "warning",
        "comment": "运算结果超出对应类型的存储范围往往意味着错误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:2011 6.5(5)-undefined,ISO/IEC 9899:2011 6.2.5(9)",
        "reference": "CWE-190,C++ Core Guidelines ES.103,C++ Core Guidelines ES.104"
    },
    "ID_constLogicExpression": {
        "checkPoint": "逻辑表达式及其子表达式的结果不应为常量",
        "level": "warning",
        "comment": "逻辑表达式及其子表达式的结果不应为常量，否则使逻辑判断失去意义。",
        "tag": "expression",
        "reference": "CWE-570,CWE-571,MISRA C 2004 13.7,MISRA C 2012 14.3"
        },
    "ID_invalidCommaSubExpression": {
        "checkPoint": "逗号表达式的子表达式应具有必要的副作用",
        "level": "warning",
        "comment": "逗号表达式的子表达式应具有必要的副作用，否则没有意义。",
        "tag": "expression",
        "related": "ID_forbidCommaExpression"
        },
    "ID_forbidCommaExpression": {
        "checkPoint": "禁用逗号表达式",
        "level": "suggestion",
        "comment": "逗号表达式将多个语句合成一个表达式，易形成笔误并造成阅读困难。",
        "config": {
            "ID_expression/allowCommaExpressionInForIteration": "为 true 可以放过 for 迭代声明中的逗号表达式"
            },
        "tag": "expression",
        "reference": "MISRA C 2004 12.10,MISRA C 2012 12.3,MISRA C++ 2008 5-18-1"
        },
    "ID_conflictCondition": {
        "checkPoint": "逻辑表达式中各子表达式不应自相矛盾",
        "level": "error",
        "comment": "在逻辑表达式中，相互矛盾的子表达式会使整个表达式的结果恒为真或恒为假，造成条件失效。",
        "tag": "expression",
        "reference": "CWE-570,CWE-571"
        },
    "ID_illIdentical": {
        "checkPoint": "不应出现不合逻辑的重复子表达式",
        "level": "error",
        "comment": "逻辑与、逻辑或、按位与、按位或的子表达式以及三元表达式的两个分枝不应重复，否则失去逻辑意义。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_illComparison": {
        "checkPoint": "比较运算应在正确的范围内进行",
        "level": "error",
        "comment": "应在正确的范围内进行比较，否则会造成恒为真或恒为假的无效结果。",
        "tag": "expression",
        "related": "ID_switch_caseOutOfRange",
        "reference": "CWE-697,CWE-1024,CWE-1025"
        },
    "ID_illPtrStrComparison": {
        "checkPoint": "指针不应与字符串常量直接比较",
        "level": "error",
        "comment": "直接比较指针和字符串常量的结果往往总是 false，应改用字符串比较函数。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2003 2.13.4(2)-implementation,ISO/IEC 14882:2011 2.14.5(12)-implementation,ISO/IEC 14882:2011 5.13.5(16)-unspecified",
        "reference": "CWE-595,CWE-697,CWE-1024,CWE-1025"
        },
    "ID_illFloatComparison": {
        "checkPoint": "不应使用 == 或 != 判断浮点数是否相等",
        "level": "warning",
        "comment": "不应使用 == 或 != 判断浮点数是否相等。",
        "tag": "expression",
        "reference": "CWE-1025,MISRA C 2004 13.3,MISRA C++ 2008 6-2-2"
        },
    "ID_successiveComparison": {
        "checkPoint": "比较运算不可作为另一个比较运算的直接子表达式",
        "level": "error",
        "comment": "在 C/C++ 语言中，连续的比较运算是没有意义的，本规则是 ID_illBoolOperation 的特化。",
        "tag": "expression",
        "related": "ID_illBoolOperation",
        "reference": "CWE-697,CWE-1024,CWE-1025"
        },
    "ID_illShiftCount": {
        "checkPoint": "移位数量不可超过相关类型比特位的数量",
        "level": "error",
        "comment": "移位数量不可过大，否则会导致标准未定义的错误。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2003 5.8(1)-undefined,ISO/IEC 14882:2011 5.8(1)-undefined,ISO/IEC 14882:2017 8.8(1)-undefined",
        "reference": "MISRA C++ 2008 5-8-1"
        },
    "ID_unexpectedPrecedence": {
        "checkPoint": "注意运算符优先级，不可产生非预期的结果",
        "level": "warning",
        "comment": "对运算符优先级的错误理解是产生逻辑错误的主要原因之一。",
        "tag": "expression",
        "reference": "CWE-783"
        },
    "ID_illPtrDiff": {
        "checkPoint": "不在同一数组中的指针不可比较或相减",
        "level": "warning",
        "comment": "不在同一数组中的指针比较或相减属于逻辑错误，会导致标准未定义的问题。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2003 5.7(6)-undefined,ISO/IEC 14882:2011 5.7(6)-undefined,ISO/IEC 14882:2011 8.7(5)-undefined",
        "reference": "MISRA C 2004 17.3,MISRA C++ 2008 5-0-17,MISRA C++ 2008 5-0-18,C++ Core Guidelines ES.62"
        },
    "ID_illBoolOperation": {
        "checkPoint": "bool 型变量或表达式不应参与大小比较、位运算、自增自减等运算",
        "level": "warning",
        "comment": "bool 值只能为真或假，不具有“大小”这种逻辑意义，所以 bool 型变量或表达式参与大小比较、位运算、自增自减等运算都是不合理的。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2011 5.3.2(1 2) D.1-deprecated",
        "reference": "CWE-1024,CWE-1025,CWE-682,CWE-783,MISRA C 2004 12.7,MISRA C 2012 10.1,MISRA C++ 2008 5-0-21"
        },
    "ID_inaccessibleTmpObject": {
        "checkPoint": "不应产生无效的临时对象",
        "level": "error",
        "comment": "无名且不受控制的临时对象在构造之后会立即析构，在逻辑上没有意义，往往意味着错误。",
        "tag": "declaration",
        "reference": "CWE-665,C++ Core Guidelines ES.84"
        },
    "ID_qualifierCastedAway": {
        "checkPoint": "类型转换时不应去掉 const、volatile 等属性",
        "level": "warning",
        "comment": "类型转换时去掉 const、volatile 等属性使相关机制失去了意义，这往往意味着设计上的缺陷，也会导致标准未定义的错误。",
        "tag": "cast",
        "standard": "ISO/IEC 14882:2003 7.1.5.1(4 5)-undefined,ISO/IEC 14882:2011 7.1.6.1(4)-undefined",
        "reference": "C++ Core Guidelines Type.3,MISRA C 2004 11.5,MISRA C 2012 11.8,MISRA C++ 2008 5-2-5"
        },
    "ID_objectSlicing": {
        "checkPoint": "避免对象切片",
        "level": "warning",
        "comment": "将派生类对象复制为基类对象的行为称为“对象切片”，基类对象不再持有派生类的属性，多态性也不再有效，意味着某种精度上的损失，往往会造成意料之外的错误。",
        "tag": "expression",
        "related": "ID_paramMayBeSlicing",
        "reference": "C++ Core Guidelines ES.63,C++ Core Guidelines C.145,SEI CERT OOP51-CPP"
        },
    "ID_userObjectAsVariadicArgument": {
        "checkPoint": "非基本类型的对象不应传入可变参数列表",
        "level": "error",
        "comment": "非基本类型的对象与可变参数列表的机制很难相容，如果这种对象被传入可变参数列表，往往意味着错误。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2011 5.2.2(7)-implementation",
        "reference": "CWE-686,SEI CERT EXP47-C"
        },
    "ID_downCast": {
        "checkPoint": "避免向下类型转换",
        "level": "suggestion",
        "comment": "当代码中出现了从基类到派生类的向下类型转换，以及可以造成数据损失的类型转换，意味着现有接口或流程不能满足需求，需要“特殊处理”，所以这种转换越少越好。",
        "tag": "cast",
        "related": "ID_nonDynamicDownCast,ID_narrowCast",
        "reference": "C++ Core Guidelines ES.48"
        },
    "ID_castNoInheritance": {
        "checkPoint": "不应强制转换无继承关系的类型",
        "level": "warning",
        "comment": "无继承关系的类型之间没有逻辑关系，不应强制转换，否则意味着设计缺陷或逻辑错误。",
        "tag": "cast",
        "related": "ID_narrowCast,ID_unsuitableReinterpretCast",
        "standard": "ISO/IEC 14882:2003 5.2.10(7)-unspecified,ISO/IEC 14882:2011 5.2.10(7)-unspecified",
        "reference": "MISRA C 2012 11.3,MISRA C++ 2008 5-2-7"
        },
    "ID_castNonPublicInheritance": {
        "checkPoint": "不应强制转换非公有继承关系的类型",
        "level": "warning",
        "comment": "公有继承表示派生类是基类的某种扩展，而非公有继承往往表示派生类是基类的某种“例外”，基类的方法不再适用于派生类的对象。",
        "standard": "ISO/IEC 9899:2011 4.10(3)",
        "tag": "cast"
        },
    "ID_redundantCast": {
        "checkPoint": "不应存在多余的类型转换",
        "level": "warning",
        "comment": "转换前后的类型完全相同是没有意义的，很可能意味着某种笔误。",
        "tag": "cast",
        "reference": "CWE-704"
        },
    "ID_functionPointerCast": {
        "checkPoint": "对函数以及函数指针不应进行类型转换",
        "level": "warning",
        "comment": "将函数指针转换为其他类型会导致标准未定义的问题。",
        "tag": "cast",
        "standard": "ISO/IEC 14882:2003 5.2.10(6)-undefined,ISO/IEC 14882:2003 5.2.10(6)-unspecified",
        "reference": "MISRA C 2004 11.1,MISRA C 2012 11.1,MISRA C++ 2008 5-2-6"
        },
    "ID_arrayPointerCast": {
        "checkPoint": "避免类型转换造成的指针运算错误",
        "level": "warning",
        "comment": "指针的逻辑大小与类型有关，不适当的类型转换会造成指针运算错误，应避免转换指向数组的指针。",
        "tag": "cast",
        "standard": "ISO/IEC 9899:1999 6.5.6(8),ISO/IEC 9899:2011 6.5.6(8)",
        "reference": "C++ Core Guidelines C.152"
        },
    "ID_nonDynamicDownCast": {
        "checkPoint": "向下类型转换时应使用 dynamic_cast",
        "level": "warning",
        "comment": "向下类型转换如果不用 dynamic_cast 难以保证安全性。",
        "tag": "cast",
        "standard": "ISO/IEC 14882:2011 5.2.7,ISO/IEC 14882:2003 5.2.9(5 8)-undefined,ISO/IEC 14882:2011 5.2.9(11 12)-undefined",
        "related": "ID_downCast",
        "reference": "MISRA C++ 2008 5-2-2,C++ Core Guidelines Type.2"
        },
    "ID_unsuitableReinterpretCast": {
        "checkPoint": "可用 static_cast、dynamic_cast 完成的类型转换不可使用 reinterpret_cast",
        "level": "warning",
        "comment": "reinterpret_cast 将某地址强行按另一种类型解释，不考虑类型转换需要的逻辑，当可以用其他方法转换时不可使用 reinterpret_cast。",
        "tag": "cast",
        "standard": "ISO/IEC 14882:2003 5.2.10(7),ISO/IEC 14882:2011 5.2.10(7)",
        "reference": "C++ Core Guidelines Type.1"
        },
    "ID_castViolatePolymorphism": {
        "checkPoint": "多态类型与基本类型不应相互转换",
        "level": "warning",
        "comment": "多态类型会维护虚表指针等用户不可见的数据以保证多态机制的执行，将其与基本类型转换会破坏这种机制。",
        "tag": "cast",
        "reference": "CWE-843"
        },
    "ID_oddNew": {
        "checkPoint": "new 表达式只可用于赋值或当作参数",
        "level": "warning",
        "comment": "new 表达式只应作为“=”的直接右子表达式，或直接作为参数表达式，其他形式均有问题。",
        "tag": "expression",
        "related": "ID_multiAllocation"
        },
    "ID_oddNewCast": {
        "checkPoint": "对 new 表达式不应进行类型转换",
        "level": "warning",
        "comment": "new 表达式本身是类型明确的，转换 new 表达式的类型不符合 C++ 严谨的类型理念，也容易造成分配、访问或回收相关的错误。",
        "tag": "cast",
        "related": "ID_forbidFlexibleArray"
        },
    "ID_narrowCast": {
        "checkPoint": "避免类型转换造成的数据丢失",
        "level": "warning",
        "comment": "类型转换时应检查转换的结果是否正确，避免数据丢失等错误。",
        "tag": "cast",
        "reference": "C++ Core Guidelines ES.46"
        },
    "ID_forbidCStyleCast": {
        "checkPoint": "在 C++ 代码中禁用 C 风格类型转换",
        "level": "suggestion",
        "comment": "C 语言的类型观念弱于 C++，易造成逻辑错误或数据丢失，应尽量避免类型转换，或使用 static_cast、dynamic_cast 等方法。",
        "tag": "cast",
        "reference": "MISRA C++ 2008 5-2-4,C++ Core Guidelines ES.49"
        },
    "ID_missingSideEffect": {
        "checkPoint": "不应存在没有副作用的语句",
        "level": "error",
        "comment": "不能对程序状态产生影响的语句称为无“副作用（side effect）”的语句，也可以说是没有效果的语句，往往属于笔误或调试痕迹，应当修正或去除。",
        "tag": "function",
        "reference": "CWE-1164,CWE-482,MISRA C 2004 14.2,MISRA C 2012 2.2,MISRA C++ 2008 0-1-9"
        },
    "ID_returnValueIgnored": {
        "checkPoint": "返回值不应被忽略",
        "level": "warning",
        "comment": "返回值不应被忽略，尤其是与资源分配、信息获取、状态判断有关的返回值。",
        "tag": "expression",
        "reference": "MISRA C 2012 17.7,MISRA C++ 2008 0-1-7"
        },
    "ID_oddPtrCharComparison": {
        "checkPoint": "指针不应与字符常量比较大小",
        "level": "warning",
        "comment": "指针与字符常量比较大小是非常怪异的，往往是某种笔误。",
        "tag": "pointer",
        "reference": "CWE-1025"
        },
    "ID_oddPtrBoolComparison": {
        "checkPoint": "指针不应与 bool 常量比较大小",
        "level": "warning",
        "comment": "指针与 bool 常量比较大小是非常怪异的，往往是某种笔误。",
        "tag": "pointer",
        "reference": "CWE-1025"
        },
    "ID_oddPtrZeroComparison": {
        "checkPoint": "不应判断指针大于、大于等于、小于、小于等于 0",
        "level": "warning",
        "comment": "指针的值是地址的编号，并没有大小的语义，指针可以与指针比较从而确定某种前后关系，但指针与整数比较大小则是没有意义的，尤其是与 0 的比较，往往意味着错误。",
        "tag": "pointer",
        "reference": "CWE-1025"
        },
    "ID_selfComparison": {
        "checkPoint": "比较运算符左右子表达式不应重复",
        "level": "warning",
        "comment": "与自身的比较是没意义的，往往是某种笔误。",
        "tag": "expression",
        "reference": "CWE-1025"
        },
    "ID_selfSubtraction": {
        "checkPoint": "减法运算符左右子表达式不应重复",
        "level": "warning",
        "comment": "与自身做减法，结果总为 0，往往是某种笔误。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_selfDivision": {
        "checkPoint": "除法运算符、求余运算符左右子表达不应重复",
        "level": "warning",
        "comment": "除法运算符、求余运算符左右子表达重复，结果总为 1 或 0 以及产生除零异常，这是没有意义的，往往是某种笔误。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_selfAssignment": {
        "checkPoint": "赋值运算符左右子表达式不应重复",
        "level": "warning",
        "comment": "对自身赋值是没有逻辑意义的，往往是笔误或残留代码。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_illSelfCompoundAssignment": {
        "checkPoint": "&=、|=、-=、/=、%= 左右子表达式不应相同",
        "level": "warning",
        "comment": "&=、|= 左右子表达式如果相同则没有任何效果，-=、/=、%= 左右子表达式相同则结果总为 1 或 0，这种表达式往往意味着笔误或逻辑错误。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_selfExclusiveOr": {
        "checkPoint": "异或运算符左右子表达式不应重复",
        "level": "warning",
        "comment": "与自身异或，结果总为 0，而且可能意味着某种错误。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_confusingAssignment": {
        "checkPoint": "赋值表达式中不应存在被赋值变量的自增或自减运算",
        "level": "warning",
        "comment": "设 a 为变量，对于下列形式的赋值给出警告：\na = a++;\na = ++a;\n++a = a;\n++a = ++a;\n++a = a++;\n这种形式的赋值非但令人费解，而且不同的编译器会给出不同的解释从而得到不同的执行结果。",
        "tag": "expression",
        "related": "ID_evaluationOrderReliance",
        "reference": "C++ Core Guidelines ES.43,SEI CERT EXP50-CPP"
        },
    "ID_oddPtrCharAssignment": {
        "checkPoint": "不应使用字符常量对指针赋值或初始化",
        "level": "warning",
        "comment": "用 '\\0'、L'\\0' 等字符常量对指针赋值或初始化是非常怪异的，往往意味错误。",
        "tag": "pointer",
        "reference": "CWE-351"
        },
    "ID_oddPtrBoolAssignment": {
        "checkPoint": "不应使用 bool 常量对指针赋值或初始化",
        "level": "warning",
        "comment": "用 false 等 bool 常量对指针赋值或初始化是非常怪异的，会对代码阅读造成误导，而且也可能是书写错误。",
        "tag": "pointer",
        "reference": "CWE-351"
        },
    "ID_oddNullAssignment": {
        "checkPoint": "不应使用 NULL 对非指针变量赋值或初始化",
        "level": "warning",
        "comment": "标识符 NULL 只应该用来表示空指针，否则会对代码阅读造成误导，而且也可能是书写错误。",
        "tag": "expression",
        "reference": "MISRA C++ 2008 4-10-1"
        },
    "ID_illFormedCompoundAssignment": {
        "checkPoint": "不应出现复合赋值的错误形式",
        "level": "warning",
        "comment": "如下形式的复合赋值表达式（设 a 和 x 为变量或表达式）：\na -= a - x;\na /= a / x;\na &= a & x;\na |= a | x;\na ^= a ^ x;\n为常见笔误，应将复合赋值改为普通赋值，或去掉重复的子表达式。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_suspiciousCompoundAssignment": {
        "checkPoint": "避免出现复合赋值的可疑形式",
        "level": "suspicious",
        "comment": "如下形式的复合赋值表达式（设 a 和 x 为变量或表达式）：\na += a + x;\na *= a * x;\na %= a % x;\na <<= a << x;\na >>= a >> x;\n为常见笔误，但在特定需求下也有其逻辑意义，故对这种表达式应给出可疑提醒。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_redundantCondition": {
        "checkPoint": "不应使用多余的逻辑子表达式",
        "level": "warning",
        "comment": "逻辑或、逻辑与的子表达式有包含关系时，其中的一个表达式是多余的。",
        "tag": "expression"
        },
    "ID_simplifiableCondition": {
        "checkPoint": "逻辑表达式应尽量保持简洁明了",
        "level": "warning",
        "comment": "逻辑或、逻辑与的子表达式可以合并成一个表达式时应尽量合并。",
        "tag": "expression"
        },
    "ID_shortCircuitSideEffect": {
        "checkPoint": "逻辑表达式的右子表达不应有副作用",
        "level": "suggestion",
        "comment": "逻辑表达式的右子表达有副作用会使代码复杂度显著增加，易产生错误，且不利于维护。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.5.13(4) 6.5.14(4),ISO/IEC 9899:2011 6.5.13(4) 6.5.14(4)",
        "reference": "MISRA C 2004 12.4,MISRA C 2012 13.5,MISRA C++ 2008 5-14-1"
        },
    "ID_evaluationOrderReliance": {
        "checkPoint": "子表达式的求值不应依赖特定的顺序",
        "level": "warning",
        "comment": "注意子表达式的求值顺序，不同的求值顺序不应导致主表达式有不同的结果。",
        "tag": "expression",
        "related": "ID_confusingAssignment",
        "reference": "CWE-758,C++ Core Guidelines ES.43,C++ Core Guidelines ES.44"
        },
    "ID_complexExpression": {
        "checkPoint": "运算符不应超过规定数量",
        "level": "suggestion",
        "comment": "运算符超过一定数量意味着表达式过于复杂，易包含潜在的错误，更不利于调试与维护，应进行适当拆分。",
        "config": {
            "ID_expression/maxOperatorCount": "运算符最大数量，超过则报出",
            "ID_expression/maxLogicOperatorCount": "逻辑运算符最大数量，超过则报出"
            },
        "tag": "expression",
        "reference": "C++ Core Guidelines ES.40"
        },
    "ID_badAssertion": {
        "checkPoint": "断言中的表达式不应恒为真",
        "level": "error",
        "comment": "恒为真的断言是没有意义的。",
        "config": {
            "ID_assertion/names": "断言函数或宏的名称，如 assert、_ASSERT_EXPR 等，用“|”分隔"
            },
        "tag": "expression",
        "standard": "ISO/IEC 9899:2011 7.2"
        },
    "ID_sideEffectAssertion": {
        "checkPoint": "断言中的表达式不应有副作用",
        "level": "error",
        "comment": "断言中的表达式如果有副作用，不能保证在所有编译设置下都有效。",
        "config": {
            "ID_assertion/names": "断言函数或宏的名称，如 assert、_ASSERT_EXPR 等，用“|”分隔"
            },
        "tag": "expression",
        "standard": "ISO/IEC 9899:2011 7.2",
        "related": "ID_macro_sideEffectArgs",
        "reference": "SEI CERT PRE31-C"
        },
    "ID_complexAssertion": {
        "checkPoint": "断言中的表达式不应过于复杂",
        "level": "suggestion",
        "comment": "断言中的表达式不应过于复杂， 否则不易定位具体是哪一项不符合断言，不利于调试。",
        "config": {
            "ID_assertion/names": "断言函数或宏的名称，如 assert、_ASSERT_EXPR 等，用“|”分隔",
            "ID_assertion/maxLogicOperatorCount": "断言表达式中“逻辑与”运算符的最大数量，超过则报出"
            },
        "tag": "expression"
        },
    "ID_explicitDtorCall": {
        "checkPoint": "不应显式调用析构函数",
        "level": "suggestion",
        "comment": "显式调用析构函数使对象在生命周期未结束的时候被析构，在逻辑上使人困惑，而且在对象生命周期结束时其析构函数仍会被执行，有可能造成资源重复释放的问题。",
        "tag": "expression",
        "related": "ID_missingResetNull"
        },
    "ID_fixedAddrToPointer": {
        "checkPoint": "不应将非零常量值赋值给指针",
        "level": "warning",
        "comment": "固定地址是不可移植的，且存在安全隐患。",
        "config": {
            "ID_expression/allowMinusOneAsPointerValue": "为 true 时可以放过 -1 作为指针值的情况"
            },
        "tag": "pointer",
        "reference": "CWE-587"
        },
    "ID_unnecessaryAllocation": {
        "checkPoint": "避免不必要的内存分配",
        "level": "warning",
        "comment": "对单独的基本变量或只包含少量基本变量的对象不应使用动态内存分配。",
        "tag": "resource",
        "related": "ID_dynamicAllocation"
        },
    "ID_stackAllocation": {
        "checkPoint": "避免使用在栈上分配内存的函数",
        "level": "warning",
        "comment": "alloca、__builtin_alloca 等在栈上分配内存的函数难以控制失败时的情况，尤其在循环中更不应使用这种函数。",
        "tag": "resource",
        "related": "ID_invalidNullCheck",
        "reference": "CWE-770,SEI CERT MEM05-C"
        },
    "ID_forbidMallocAndFree": {
        "checkPoint": "C++ 代码中禁用 malloc、free 等内存管理函数",
        "level": "warning",
        "comment": "malloc、free 是 C 语言的内存管理函数，在 C++ 代码中应使用面向对象的内存管理方法。",
        "tag": "resource",
        "related": "ID_ownerlessResource",
        "reference": "C++ Core Guidelines R.10"
    },
    "ID_ownerlessResource": {
        "checkPoint": "资源管理应遵循面向对象的方法",
        "level": "warning",
        "comment": "动态申请的资源应接受对象化管理，使资源的生命周期与对象的生命周期一致，从而实现资源的自动回收，这是 C++ 程序设计的重要方法。",
        "tag": "resource",
        "reference": "C++ Core Guidelines R.11,C++ Core Guidelines R.12"
        },
    "ID_dynamicAllocation": {
        "checkPoint": "避免动态内存分配",
        "level": "warning",
        "comment": "对于标准库提供的动态内存分配方法，其策略和算法不在使用者的控制之内，很多细节是标准没有明确规定的，而且也是内存泄漏或耗尽等问题的根源，对于有高可靠性要求的嵌入式软件系统可酌情选取本规则。",
        "tag": "resource",
        "standard": "ISO/IEC 9899:1999 7.20.3,ISO/IEC 9899:2011 7.22.3",
        "reference": "MISRA C 2004 20.4,MISRA C 2012 21.3,MISRA C++ 2008 18-4-1,C++ Core Guidelines R.5"
        },
    "ID_unsuitableMove": {
        "checkPoint": "合理使用 std::move",
        "level": "warning",
        "comment": "std::move 的参数应为左值，返回值应直接作为接口的参数，除此之外的应用价值有限，且易产生错误。",
        "tag": "expression",
        "reference": "C++ Core Guidelines ES.56,C++ Core Guidelines F.18,C++ Core Guidelines F.48"
        },
    "ID_useAfterMove": {
        "checkPoint": "对象被 std::move 之后不应再被使用",
        "level": "warning",
        "comment": "std::move 宣告对象的数据即将被转移到其他对象，转移之后对象在逻辑上不再有效，不应再被使用。",
        "tag": "resource",
        "related": "ID_unsuitableMove",
        "reference": "SEI CERT EXP63-CPP,C++ Core Guidelines ES.56"
        },
    "ID_unsuitableForward": {
        "checkPoint": "合理使用 std::forward",
        "level": "warning",
        "comment": "std::forward 的参数应为“转发引用（forwarding references）”，返回值应直接作为接口的参数，除此之外的使用方式价值有限，且易产生错误。",
        "tag": "expression",
        "related": "ID_illForwardingReference",
        "reference": "C++ Core Guidelines F.19"
        },
    "ID_illForwardingReference": {
        "checkPoint": "转发引用只应作为 std::forward 的参数",
        "level": "warning",
        "comment": "不应混淆转发引用与右值引用，除作为 std::forward 的参数之外，不应对转发引用再有任何操作。",
        "tag": "function",
        "related": "ID_unsuitableForward",
        "reference": "C++ Core Guidelines F.19"
        },
    "ID_multiAllocation": {
        "checkPoint": "在一个语句中最多执行一次显式资源分配",
        "level": "warning",
        "comment": "在一个语句中最多执行一次显式资源分配，否则某个对象的构造函数抛出异常的话，会造成内存泄漏。",
        "tag": "resource",
        "reference": "C++ Core Guidelines R.13"
        },
    "ID_recursion": {
        "checkPoint": "避免递归实现",
        "level": "warning",
        "comment": "递归实现，如函数直接或间接地调用自身，易导致难以控制的堆栈溢出错误。",
        "tag": "function",
        "reference": "MISRA C 2012 17.2,MISRA C++ 2008 7-5-4"
        },
    "ID_disorderedInitialization": {
        "checkPoint": "成员初始化应遵循声明的顺序",
        "level": "error",
        "comment": "类成员的初始化顺序是按声明的顺序进行的，如果用后面的成员初始化前面的成员，就会造成错误。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2003 12.6.2(5),ISO/IEC 14882:2011 12.6.2(10)",
        "reference": "C++ Core Guidelines C.47"
        },
    "ID_memberInitialization": {
        "checkPoint": "成员须在声明处或构造时初始化",
        "level": "warning",
        "comment": "由于成员声明的位置和使用的位置相距较远，所以更容易造成未初始化先使用的问题，应该在声明处或构造函数中初始化所有需要初始化的成员。",
        "tag": "function",
        "reference": "CWE-908,CWE-824,C++ Core Guidelines C.41"
        },
    "ID_invalidWrite": {
        "checkPoint": "避免无效写入",
        "level": "warning",
        "comment": "对于内存中的数据，写入之后应被读取，否则没有意义。",
        "tag": "function"
        },
    "ID_memberDeallocation": {
        "checkPoint": "对象申请的资源须在析构函数中释放",
        "level": "warning",
        "comment": "对象在析构函数中释放自己申请的资源是 C++ 程序设计的重要原则，不可被遗忘，也不应要求用户释放。",
        "tag": "resource",
        "related": "ID_memoryLeak,ID_resourceLeak",
        "reference": "C++ Core Guidelines C.31,C++ Core Guidelines E.6"
        },
    "ID_virtualCallInConstructor": {
        "checkPoint": "在构造函数中不应调用虚函数",
        "level": "warning",
        "comment": "虚函数在构造函数中的多态性不生效，而且调用未定义的纯虚函数会导致标准未定义的错误。",
        "tag": "function",
        "reference": "C++ Core Guidelines C.82,Effective C++ item 9"
        },
    "ID_virtualCallInDestuctor": {
        "checkPoint": "在析构函数中不应调用虚函数",
        "level": "warning",
        "comment": "虚函数在析构函数中的多态性不生效，而且调用未定义的纯虚函数会导致标准未定义的错误。",
        "tag": "function",
        "reference": "C++ Core Guidelines C.82,Effective C++ item 9"
        },
    "ID_sideEffectCopyConstructor": {
        "checkPoint": "拷贝构造函数应避免实现复制之外的功能",
        "level": "warning",
        "comment": "拷贝构造函数可以被优化而不被执行，而且这种优化是由实现定义的。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2003 12.8(15)-implementation,ISO/IEC 14882:2011 12.8(31)-implementation",
        "reference": "MISRA C++ 2008 12-8-1"
        },
    "ID_throwInConstructor":{
        "checkPoint": "如果构造函数抛出异常需确保相关资源没有泄漏",
        "level": "warning",
        "comment": "构造函数抛出异常表示对象构造失败，不会再执行相关析构函数，需要保证已分配的资源被有效回收。",
        "tag": "resource",
        "related": "ID_ownerlessResource,ID_multiAllocation,ID_memoryLeak"
        },
    "ID_throwInDestuctor": {
        "checkPoint": "析构函数不可抛出异常",
        "level": "error",
        "comment": "析构函数抛出异常是违反异常处理机制的。",
        "tag": "exception",
        "related": "ID_throwInHash,ID_throwInSwap,ID_throwInMove",
        "standard": "ISO/IEC 14882:2003 15.2(3),ISO/IEC 14882:2011 15.2(3),ISO/IEC 14882:2011 3.7.4.2-undefined",
        "reference": "C++ Core Guidelines C.36,C++ Core Guidelines C.37,C++ Core Guidelines E.16,SEI CERT DCL57-CPP,MISRA C++ 2008 15-5-1"
        },
    "ID_throwInHash": {
        "checkPoint": "与 STL 标准库相关的 hash 过程不应抛出异常",
        "level": "suggestion",
        "comment": "对象的 hash 过程中不应抛出异常，否则相关的容器和算法无法正常工作。",
        "tag": "exception",
        "reference": "C++ Core Guidelines C.89"
        },
    "ID_throwInSwap": {
        "checkPoint": "对象的 swap 过程不可抛出异常",
        "level": "warning",
        "comment": "两个对象在 swap（交换）过程中，每个对象的状态都是不完整的，如果在交换中途抛出异常，对象将处于错误的状态无法恢复。",
        "tag": "exception",
        "related": "ID_exceptionUnsafe,ID_throwInMove",
        "reference": "C++ Core Guidelines C.84,C++ Core Guidelines C.85"
        },
    "ID_throwInMove": {
        "checkPoint": "移动构造函数和移动赋值运算符不可抛出异常",
        "level": "warning",
        "comment": "移动构造函数和移动赋值运算符在本质上相当于将当前对象与临时对象“交换”，交换过程不可抛出异常，可参见 ID_throwInSwap。",
        "tag": "exception",
        "related": "ID_throwInSwap",
        "reference": "C++ Core Guidelines C.66"
        },
    "ID_localAddressFlowOut": {
        "checkPoint": "不可返回局部对象的地址或引用",
        "level": "error",
        "comment": "局部对象的生命周期在函数返回后结束，其地址或引用也会失效，如果继续访问会造成标准未定义的错误。",
        "tag": "function",
        "standard": "ISO/IEC 9899:1999 6.2.4(2)-undefined,ISO/IEC 9899:2011 6.2.4(2)-undefined",
        "reference": "CWE-562,C++ Core Guidelines F.43"
        },
    "ID_unreachableCode": {
        "checkPoint": "不应存在得不到执行机会的代码",
        "level": "error",
        "comment": "得不到执行机会的代码是没有意义的，往往意味着逻辑错误。",
        "tag": "function",
        "related": "ID_staticNotUsed,ID_privateNotUsed,ID_constLogicExpression,ID_invalidCondition,ID_switch_caseOutOfRange,ID_if_identicalCondition,ID_if_hiddenCondition",
        "reference": "CWE-561,MISRA C 2004 14.1,MISRA C 2012 2.1,MISRA C++ 2008 0-1-1"
        },
    "ID_localInitialization": {
        "checkPoint": "局部变量在使用前必须初始化",
        "level": "error",
        "comment": "未经初始化即使用的局部变量，其值是不确定的，意味着程序存在严重逻辑错误。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2003 8.5(9),ISO/IEC 14882:2011 8.5(11),ISO/IEC 14882:2017 11.6(12)",
        "reference": "CWE-909,CWE-908,CWE-824,CWE-457,C++ Core Guidelines ES.20,MISRA C 2004 9.1,MISRA C 2012 9.1,MISRA C++ 2008 8-5-1"
        },
    "ID_notAllBranchReturn": {
        "checkPoint": "有返回值的函数其所有分枝都应有明确的返回值",
        "level": "error",
        "comment": "当函数的某个分枝没有明确的返回值时会引发标准未定义的错误。",
        "tag": "function",
        "standard": "ISO/IEC 9899:1999 6.9.1(12)-undefined,ISO/IEC 9899:1999 5.1.2.2.3(1),ISO/IEC 9899:2011 6.9.1(12)-undefined,ISO/IEC 9899:2011 5.1.2.2.3(1),ISO/IEC 14882:2011 6.6.3(2)-undefined,ISO/IEC 14882:2017 9.6.3(2)-undefined",
        "reference": "CWE-394,MISRA C 2004 16.8,MISRA C 2012 17.4,MISRA C++ 2008 8-4-3"
        },
    "ID_returnSameConst": {
        "checkPoint": "函数返回值不应为相同的常量",
        "level": "warning",
        "comment": "如果一个函数有多个返回语句，但所有返回值都是相同的常量，那么这个函数的返回值是没有意义的。",
        "tag": "function"
        },
    "ID_returnOdd": {
        "checkPoint": "返回值应与函数的返回类型相符",
        "level": "warning",
        "comment": "返回值应与函数的返回类型相符。",
        "tag": "function",
        "reference": "MISRA C++ 2008 4-10-1"
        },
    "ID_redundantJump": {
        "checkPoint": "不应出现多余的跳转语句",
        "level": "warning",
        "comment": "无返回值函数的最后一条 return 语句、循环体的最后一条 continue 语句、goto 到下一条语句等是多余的，应当去除。",
        "tag": "function"
        },
    "ID_paramPassedByValue": {
        "checkPoint": "由 const 修饰的参数应为引用或指针",
        "level": "warning",
        "comment": "函数参数按值传递时会产生复制及构造开销，而且如果有 const 修饰，意味着对象不可改变，那么按值传递是没有意义的。",
        "tag": "function",
        "reference": "C++ Core Guidelines F.16"
        },
    "ID_paramMayBeSlicing": {
        "checkPoint": "多态类的对象作为参数时不应采用值传递的方式",
        "level": "warning",
        "comment": "将派生类对象通过传值的方式转换为基类对象后，不再遵循多态机制，易产生意料之外的错误，应采用指针或引用的方式传递多态类对象。",
        "tag": "function",
        "related": "ID_objectSlicing",
        "reference": "C++ Core Guidelines C.145,C++ Core Guidelines ES.63"
        },
    "ID_relyOnExternalObject": {
        "checkPoint": "全局对象的初始化不可依赖未初始化的对象",
        "level": "warning",
        "comment": "全局对象的初始化不可依赖其他源文件中定义的对象，也不可依赖在其后面定义的对象。",
        "tag": "global",
        "standard": "ISO/IEC 14882:2011 3.6.2(2 3),ISO/IEC 14882:2017 6.6.2(3),ISO/IEC 14882:2017 6.6.3(2)",
        "reference": "C++ Core Guidelines I.22"
        },
    "ID_abusedAuto": {
        "checkPoint": "使用 auto 关键字需注意可读性",
        "level": "suggestion",
        "comment": "auto 关键字隐藏了类型名称，在使用时需注意不应降低可读性。",
        "tag": "declaration",
        "related": "ID_roughAuto",
        "reference": "C++ Core Guidelines ES.11"
        },
    "ID_roughAuto": {
        "checkPoint": "用 auto 声明指针或引用时应显式标明 *、& 等符号",
        "level": "suggestion",
        "comment": "用 auto 声明指针时显式标明 * 号有利于提高代码可读性，否则会使人误以为是某种非指针的对象。在声明引用时必须显式标明 & 或 && 号，否则成为对象声明，导致逻辑错误或造成不必要的复制开销。",
        "tag": "declaration"
        },
    "ID_selfDependentInitialization": {
        "checkPoint": "对象初始化不可依赖自身的值",
        "level": "error",
        "comment": "对象初始化依赖自身的值属于逻辑错误，也是常见的笔误。",
        "tag": "declaration"
        },
    "ID_invalidLocalDeclaration": {
        "checkPoint": "不应出现不会被用到的局部声明",
        "level": "warning",
        "comment": "不会被用到的局部声明是没有意义的，往往意味着笔误或者代码功能不完整。",
        "tag": "declaration"
        },
    "ID_tooManyParams": {
        "checkPoint": "函数参数的数量应在规定范围之内",
        "level": "warning",
        "comment": "函数参数的数量应在规定范围之内。",
        "config": {
            "ID_declaration/maxParamCount": "参数数量上限，超过则报出",
            "ID_declaration/maxInnerFunParamCount": "static 函数或 private 成员函数参数数量上限，超过则报出"
            },
        "tag": "function",
        "reference": "C++ Core Guidelines F.2,C++ Core Guidelines I.23"
        },
    "ID_paramNotUsed": {
        "checkPoint": "不应存在未被使用的具名形式参数",
        "level": "suggestion",
        "comment": "如果函数的某个参数在函数内没有被用到过，意味着函数的功能与设计预期存在差距。",
        "tag": "function",
        "reference": "C++ Core Guidelines F.9,MISRA C 2012 2.7,MISRA C++ 2008 0-1-11"
        },
    "ID_inconsistentParamName": {
        "checkPoint": "函数的参数名称在声明和实现处应保持一致",
        "level": "warning",
        "comment": "函数的参数名称在声明和实现处不一致甚至顺序也不相同，会对函数的调用者造成误导，而且不能排除是实现上的错误。",
        "tag": "function",
        "reference": "MISRA C++ 2008 8-4-2"
        },
    "ID_definedInHeader": {
        "checkPoint": "函数不应在头文件中实现",
        "level": "warning",
        "comment": "在头文件中实现的函数，如果不是内联、静态或模板函数，则可能被引入不同的翻译单元（translate-unit）造成编译冲突。",
        "tag": "function",
        "reference": "C++ Core Guidelines SF.2"
        },
    "ID_complexInlineFunction": {
        "checkPoint": "不应定义过于复杂的内联函数",
        "level": "suggestion",
        "comment": "当有如下情况时，不适合将函数声明为内联函数：\n1. 行数超过指定限制\n2. 存在循环或异常处理语句\n3. 存在switch分枝语句\n4. 函数为递归函数\n实际上如果出现以上情况，编译器也不会将其实现为内联函数。",
        "config": {
            "ID_function/maxInlineFunctionLineCount": "内联函数行数上限，超过则报出"
            },
        "tag": "function",
        "reference": "C++ Core Guidelines F.5"
        },
    "ID_nonVirtualOverride": {
        "checkPoint": "派生类不应重新定义与基类相同的非虚函数",
        "level": "warning",
        "comment": "派生类不应重新定义与基类相同的非虚函数，否则与多态机制相矛盾，易造成意料之外的问题。",
        "tag": "declaration",
        "reference": "Effective C++ item 36"
        },
    "ID_unsuitableReturn": {
        "checkPoint": "属性为 noreturn 的函数中不应出现 return 语句",
        "level": "warning",
        "comment": "属性为 noreturn 的函数中出现 return 语句说明函数还是可以正常返回的，这种矛盾会对调用者造成很大困扰，而且会导致标准未定义的问题。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2011 7.6.3(2)-undefined"
        },
    "ID_unsuitableReturnType": {
        "checkPoint": "属性为 noreturn 的函数返回类型只应为 void",
        "level": "warning",
        "comment": "属性为 noreturn 的函数返回类型不是 void 说明函数还是有返回值的，这种矛盾会对调用者造成很大困扰。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2011 7.6.3(2)-undefined"
        },
    "ID_overloadLogicOperator": {
        "checkPoint": "不应重载“逻辑与”和“逻辑或”运算符",
        "level": "suggestion",
        "comment": "对“逻辑与”、“逻辑或”等运算符的重载会影响效率，甚至造成与预期完全不符的结果。",
        "tag": "declaration",
        "related": "ID_overloadComma",
        "reference": "MISRA C++ 2008 5-2-11"
        },
    "ID_overloadComma": {
        "checkPoint": "不应重载逗号运算符",
        "level": "suggestion",
        "comment": "对于内置逗号表达式，标准规定从左到右计算子表达式的值，但对逗号运算符的重载会打破这一规则，造成不符合预期的结果。",
        "tag": "declaration",
        "related": "ID_overloadLogicOperator",
        "reference": "MISRA C++ 2008 5-2-11"
        },
    "ID_overloadAddressOperator": {
        "checkPoint": "不应重载取地址运算符",
        "level": "suggestion",
        "comment": "取地址运算符（一元 & 运算符），重载之后可以返回任意地址，极易误用。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 5.3.1(4)-undefined,ISO/IEC 14882:2011 5.3.1(5)-undefined",
        "reference": "C++ Core Guidelines C.166,MISRA C++ 2008 5-3-3"
        },
    "ID_missingVirtualDestructor": {
        "checkPoint": "有虚函数的基类应具有虚析构函数",
        "level": "warning",
        "comment": "为了避免意料之外的资源泄漏，有虚函数的基类，都应该具有虚析构函数。",
        "tag": "type",
        "standard": "ISO/IEC 14882:2003 12.4(7) 5.3.5(3),ISO/IEC 14882:2011 12.4(9) 5.3.5(3),ISO/IEC 14882:2017 15.4(10) 8.3.5(3)",
        "reference": "CWE-1079,CWE-1087,CWE-1045,C++ Core Guidelines C.35,C++ Core Guidelines C.127"
        },
    "ID_diamondInheritance": {
        "checkPoint": "用虚基类避免冗余的基类实例",
        "level": "suggestion",
        "comment": "当一个类有多个基类，这些基类又继承自同一个类时，会产生多个不同的基类实例，造成逻辑上的冗余和不必要的存储开销。",
        "tag": "type",
        "standard": "ISO/IEC 14882:2011 10.1(4 5 6 7),ISO/IEC 14882:2003 5.2.9(5 8)-undefined,ISO/IEC 14882:2011 5.2.9(11 12)-undefined",
        "reference": "C++ Core Guidelines C.137"
        },
    "ID_roughTemplateConstructor": {
        "checkPoint": "带模板的构造函数不应覆盖拷贝或移动构造函数",
        "level": "warning",
        "comment": "带模板的构造函数覆盖拷贝或移动构造函数，很可能导致意料之外的错误。",
        "tag": "type",
        "related": "ID_roughTemplateAssignOperator",
        "reference": "MISRA C++ 2008 14-5-2"
        },
    "ID_roughTemplateAssignOperator": {
        "checkPoint": "带模板的赋值运算符不应覆盖拷贝或移动赋值运算符",
        "level": "warning",
        "comment": "带模板的赋值运算符覆盖拷贝或移动赋值运算符，很可能导致意料之外的错误。",
        "tag": "type",
        "related": "ID_roughTemplateConstructor",
        "reference": "MISRA C++ 2008 14-5-3"
        },
    "ID_missingExplicitOverride": {
        "checkPoint": "所有重写的虚函数都应声明为 override 或 final",
        "level": "suggestion",
        "comment": "将重写的虚函数都声明为 override 或 final，可明显提升代码可读性，并可确保虚函数被有效重写。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2011 10.3(4 5)",
        "reference": "C++ Core Guidelines C.128"
        },
    "ID_incompleteNewDeletePair": {
        "checkPoint": "重载的 new 和 delete 运算符应配对出现",
        "level": "suggestion",
        "comment": "如果重载内存的分配方式，一定要重载相应的回收方式，反之亦然，否则容易造成分配与回收的冲突。",
        "tag": "type",
        "reference": "C++ Core Guidelines R.15"
        },
    "ID_stdNamespaceModified": {
        "checkPoint": "不可修改 std 命名空间",
        "level": "warning",
        "comment": "可以为用户定义的类型特化某些标准模板类，除此之外对 std 命名空间添加、修改甚至删除任何代码所导致的后果都是标准未定义的。",
        "tag": "global",
        "standard": "ISO/IEC 14882:2011 17.6.4.2.1(1 2),ISO/IEC 14882:2017 20.5.4.2.1(1 2)",
        "reference": "SEI CERT DCL58-CPP"
        },
    "ID_usingSelf": {
        "checkPoint": "避免无效的 using directive",
        "level": "warning",
        "comment": "用 using directive 引用当前命名空间属于无效代码，可能意味着某种错误。",
        "tag": "global"
        },
    "ID_anonymousNamespaceInHeader": {
        "checkPoint": "头文件中不应定义匿名命名空间",
        "level": "warning",
        "comment": "头文件中定义了匿名命名空间，即相当于在头文件中定义了静态数据，头文件被多个源文件包含时便会造成数据冗余。",
        "tag": "global",
        "related": "ID_staticInHeader",
        "standard": "ISO/IEC 14882:2011 7.3.1.1",
        "reference": "C++ Core Guidelines SF.21,MISRA C++ 2008 7-3-3"
        },
    "ID_topInlineNamespace": {
        "checkPoint": "不应定义全局 inline 命名空间",
        "level": "suggestion",
        "comment": "定义全局 inline 命名空间相当于没有命名空间，应在普通命名空间之内使用 inline 命令空间。",
        "tag": "global"
        },
    "ID_usingNamespaceInHeader": {
        "checkPoint": "头文件中不应使用 using directive",
        "level": "warning",
        "comment": "在头文件的全局作用域中使用 using directive，极易造成命名冲突，且影响范围难以控制。",
        "tag": "global",
        "related": "ID_forbidUsingDirectives",
        "reference": "C++ Core Guidelines SF.7,MISRA C++ 2008 7-3-6"
        },
    "ID_forbidUsingDirectives": {
        "checkPoint": "全局或命名空间作用域中禁用 using directive",
        "level": "suggestion",
        "comment": "将其他命名空间中的名称一并引入当前命名空间，是对命名空间机制的破坏。",
        "tag": "global",
        "related": "ID_usingNamespaceInHeader",
        "reference": "C++ Core Guidelines SF.6,MISRA C++ 2008 7-3-4"
        },
    "ID_staticInAnonymousNamespace": {
        "checkPoint": "匿名命名空间中不应使用静态声明",
        "level": "warning",
        "comment": "匿名命名空间中的元素已具有静态属性（internal linkage），不应再用 static 关键字修饰。",
        "tag": "global",
        "standard": "ISO/IEC 14882:2011 3.5(4)"
        },
    "ID_staticAndConst": {
        "checkPoint": "全局对象不应同时被 static 和 const 关键字修饰",
        "level": "warning",
        "comment": "由 const 关键字修饰的全局对象已具有静态属性（internal linkage），不应再用 static 关键字修饰。",
        "tag": "global",
        "related": "ID_staticInHeader",
        "standard": "ISO/IEC 14882:2003 7.1.1(6),ISO/IEC 14882:2011 7.1.1(7)"
        },
    "ID_staticInHeader": {
        "checkPoint": "头文件中不应使用静态声明",
        "level": "warning",
        "comment": "头文件中由 static 关键字声明的对象、数组或函数，会在每个包含该头文件的翻译单元（translate-unit）中生成副本造成数据冗余，如果将静态数据误用作全局数据也会造成逻辑错误。",
        "tag": "global",
        "standard": "ISO/IEC 14882:2011 3.5(3)"
        },
    "ID_nameTooShort": {
        "checkPoint": "全局名称应遵循合理的命名方式",
        "level": "suggestion",
        "comment": "全局名称应具有标识性，长度不应过短，否则易与局部名称产生冲突。",
        "config": {
            "ID_global/ minVariableNameLength": "全局对象名称长度下限，小于则报出",
            "ID_global/minFunctionNameLength": "全局函数名称长度下限，小于则报出",
            "ID_global/minNameSpaceNameLength": "全局命名空间名称长度下限，小于则报出",
            "ID_global/minTypeNameLength": "全局类型名称长度下限，小于则报出"
            },
        "tag": "global",
        "related": "ID_badName",
        "reference": "C++ Core Guidelines NL.7"
        },
    "ID_if_semicolon": {
        "checkPoint": "if 语句不应被分号隔断",
        "level": "error",
        "comment": "if 语句不应被分号隔断。",
        "tag": "control",
        "reference": "CWE-670"
        },
    "ID_if_identicalCondition": {
        "checkPoint": "在 if...else-if 分枝中不应有重复的条件",
        "level": "error",
        "comment": "if...else-if 分枝的条件不应有重复，否则相同条件排在前面的分枝会得以执行，而排在后面的分枝得不到执行机会。",
        "tag": "control",
        "related": "ID_if_hiddenCondition",
        "reference": "CWE-670,CWE-561"
        },
    "ID_if_hiddenCondition": {
        "checkPoint": "在 if...else-if 分枝中不应有被遮盖的条件",
        "level": "error",
        "comment": "if...else-if 分枝中，如果前面的条件被满足，后面的分枝就不会被执行，所以如果前面的条件是后面条件的一部分，或者前面的条件包含后面的条件，即使后面的条件可以被满足，其分枝也得不到执行机会。",
        "tag": "control",
        "related": "ID_if_identicalCondition",
        "reference": "CWE-670,CWE-561"
        },
    "ID_if_identicalBlock": {
        "checkPoint": "if 分枝和 else 分枝的代码不应完全相同",
        "level": "error",
        "comment": "if 分枝和 else 分枝完全相同会使条件判断失去意义，往往是由复制粘贴造成的错误。",
        "tag": "control",
        "related": "ID_if_identicalElseIfBlock,ID_if_identicalImplicitElseBlock",
        "reference": "CWE-670"
        },
    "ID_if_identicalElseIfBlock": {
        "checkPoint": "if...else-if 各分枝的代码不应完全相同",
        "level": "warning",
        "comment": "内容完全相同的分枝是没有意义的，也可能是由复制粘贴造成的错误。",
        "config": {
            "ID_if/identicalBlockThreshold": "重复分枝符号数量限制，不检查符号数量小于该值的分枝"
            },
        "tag": "control",
        "related": "ID_if_identicalBlock",
        "reference": "CWE-670"
        },
    "ID_if_identicalImplicitElseBlock": {
        "checkPoint": "if 分枝和其隐含的 else 分枝的代码不应完全相同",
        "level": "warning",
        "comment": "带有 return、throw 或 break 等子句的 if 语句，其同一作用域的后续代码相当于它的 else 分枝，显然这种隐含的 else 分枝与 if 分枝完全相同是没有意义的，很可能是由复制粘贴造成的错误。",
        "tag": "control",
        "related": "ID_if_identicalElseIfBlock,ID_if_identicalSucceedingBlock",
        "reference": "CWE-670"
        },
    "ID_if_identicalSucceedingBlock": {
        "checkPoint": "没有 else 子句的 if 语句与其后续代码相同是可疑的",
        "level": "suspicious",
        "comment": "if 语句与其同一作用域的后续代码完全相同是可疑的，可能是由复制粘贴造成的错误。",
        "tag": "control",
        "related": "ID_if_identicalImplicitElseBlock",
        "reference": "CWE-670"
        },
    "ID_if_commonStatements": {
        "checkPoint": "if 分枝和 else 分枝的起止语句不应相同",
        "level": "suggestion",
        "comment": "if 分枝和 else 分枝的起止语句如果相同，则应将其从分枝结构中提取出来，否则重复的代码不利于阅读和维护。",
        "tag": "control",
        "related": "ID_if_identicalBlock",
        "reference": "CWE-670,C++ Core Guidelines ES.3"
        },
    "ID_if_scope": {
        "checkPoint": "if 语句作用域的范围不应有误",
        "level": "warning",
        "comment": "if 语句作用域的范围不应有误。",
        "tag": "control",
        "related": "ID_if_brace",
        "reference": "CWE-483"
        },
    "ID_if_mayBeElseIf": {
        "checkPoint": "如果 if 关键字前面是右大括号，if 关键字应另起一行",
        "level": "suspicious",
        "comment": "当 if 关键字前面是右大括号，且 if 关键字与该大括号在同一行时，属于不良换行方式，易造成 else 等关键字的遗漏。",
        "tag": "control"
        },
    "ID_if_assignment": {
        "checkPoint": "if 语句的条件不应为赋值表达式",
        "level": "warning",
        "comment": "虽然语言允许在 if 语句的条件中赋值，但 = 和 == 极易混淆，建议所有产生 bool 型结果的表达式，都不要包含赋值运算符。",
        "tag": "control",
        "config": {
            "ID_if_assignment/allowEnclosedAssignment": "为 true 可以放过括号括起来的赋值表达式"
            },
        "reference": "CWE-480,CWE-481,CWE-783"
        },
    "ID_if_brace": {
        "checkPoint": "if 分枝中的语句应该用大括号括起来",
        "level": "suggestion",
        "comment": "组成 if 分枝的语句应为大括号括起来的复合语句，即使该复合语句只包含一条语句。",
        "tag": "control",
        "related": "ID_do_brace,ID_for_brace,ID_while_brace,ID_switch_brace",
        "reference": "MISRA C 2004 14.9,MISRA C 2012 15.6,MISRA C++ 2008 6-4-1"
        },
    "ID_if_emptyBlock": {
        "checkPoint": "if 语句不应为空",
        "level": "warning",
        "comment": "如果 if 语句没有 else 分枝，且其分枝内容为空，这样的 if 语句无任何意义，即使其条件有副作用，也不应继续保留该if结构。",
        "tag": "control",
        "reference": "CWE-1071"
        },
    "ID_if_missingEndingElse": {
        "checkPoint": "所有 if...else-if 分枝都应以 else 子句结束",
        "level": "suggestion",
        "comment": "所有 if...else if 分枝都以 else 子句结束是非常好的编程习惯，这与要求 switch 语句包含 defualt 分枝一样，是“防御性编程”思想的良好体现，参见 ID_switch_missingDefault。",
        "tag": "control",
        "related": "ID_switch_missingDefault",
        "reference": "MISRA C 2012 15.7,MISRA C++ 2008 6-4-2"
        },
    "ID_while_semicolon": {
        "checkPoint": "while 语句不应被分号隔断",
        "level": "error",
        "comment": "while 语句不应被分号隔断。",
        "tag": "control",
        "reference": "CWE-670"
        },
    "ID_while_uncondBroken": {
        "checkPoint": "while 语句中不应存在无条件的跳转语句",
        "level": "error",
        "comment": "不受条件限制的 return、throw 或 break 语句会使循环失效，不受条件限制的 continue 语句会使其后面的代码失效，如果其后没有代码，该 continue 语句是没有意义的。",
        "tag": "control",
        "related": "ID_for_uncondBroken",
        "reference": "CWE-670"
        },
    "ID_while_assignment": {
        "checkPoint": "while 语句的条件不应为赋值表达式",
        "level": "warning",
        "comment": "虽然语言允许在 while 语句的条件中赋值，但 = 和 == 极易混淆，建议所有产生 bool 型结果的表达式，都不要包含赋值运算符。",
        "tag": "control",
        "related": "ID_if_assignment",
        "reference": "CWE-480,CWE-783"
        },
    "ID_while_scope": {
        "checkPoint": "while 语句作用域的范围不应有误",
        "level": "warning",
        "comment": "while 语句作用域的范围不应有误。",
        "tag": "control",
        "related": "ID_while_brace",
        "reference": "CWE-483"
        },
    "ID_while_brace": {
        "checkPoint": "while 循环体应该用大括号括起来",
        "level": "suggestion",
        "comment": "while 循环体应为复合语句，即使只包含一条语句。",
        "tag": "control",
        "related": "ID_do_brace,ID_for_brace,ID_if_brace,ID_switch_brace,ID_switch_onlyDefault,ID_switch_onlyOneCase",
        "reference": "MISRA C 2004 14.8,MISRA C 2012 15.6,MISRA C++ 2008 6-3-1"
        },
    "ID_while_emptyBlock": {
        "checkPoint": "while 循环体不应为空",
        "level": "suggestion",
        "comment": "空的 while 循环将逻辑功能全部压缩到了条件表达式中，可读性较差。",
        "tag": "control",
        "reference": "CWE-1071,C++ Core Guidelines ES.85"
        },
    "ID_do_emptyBlock": {
        "checkPoint": "do-while 循环体不应为空",
        "level": "suggestion",
        "comment": "空的 do-while 循环将逻辑功能全部压缩到了条件表达式中，可读性较差。",
        "tag": "control",
        "related": "ID_while_emptyBlock",
        "reference": "CWE-1071,C++ Core Guidelines ES.85"
        },
    "ID_do_suspiciousContinue": {
        "checkPoint": "注意 do-while(false) 中可疑的 continue 语句",
        "level": "warning",
        "comment": "continue 语句和 break 语句在语义上是不同的，但在 do-while(false) 中它们的功效是一样的。",
        "tag": "control",
        "reference": "CWE-670"
        },
    "ID_do_brace": {
        "checkPoint": "do-while 循环体应该用大括号括起来",
        "level": "suggestion",
        "comment": "do-while 循环体应为复合语句，即使只包含一条语句。如果没有合理的大括号，可能会与内嵌的 while 语句形成难以发觉的错误。",
        "tag": "control",
        "related": "ID_for_brace,ID_if_brace,ID_switch_brace,ID_while_brace",
        "reference": "MISRA C 2004 14.9,MISRA C 2012 15.6,MISRA C++ 2008 6-4-1"
        },
    "ID_do_deprecated": {
        "checkPoint": "不建议使用 do 语句",
        "level": "suggestion",
        "comment": "do 语句的终止条件在末尾，且第一次执行时不检查终止条件，可读性较低，不利于维护。",
        "tag": "control",
        "reference": "C++ Core Guidelines ES.75"
        },
    "ID_for_semicolon": {
        "checkPoint": "for 语句不应被分号隔断",
        "level": "error",
        "comment": "for 语句不应被分号隔断。",
        "tag": "control",
        "related": "ID_do_brace,ID_if_brace,ID_switch_brace,ID_while_brace",
        "reference": "CWE-670"
        },
    "ID_for_uncondBroken": {
        "checkPoint": "for 循环中不应存在无条件的跳转语句",
        "level": "error",
        "comment": "无条件的 return、throw 或 break 语句会使循环失效，无条件的 continue 语句会使其后面的代码失效，如果其后没有代码时，该 continue 语句是没有意义的。",
        "tag": "control",
        "related": "ID_while_uncondBroken",
        "reference": "CWE-670"
        },
    "ID_for_scope": {
        "checkPoint": "for 语句作用域的范围不应有误",
        "level": "warning",
        "comment": "for 语句作用域的范围不应有误。",
        "tag": "control",
        "related": "ID_for_brace",
        "reference": "CWE-483"
        },
    "ID_for_simplification": {
        "checkPoint": "如果 for 语句没有明显的循环变量则应改为 while 循环",
        "level": "suggestion",
        "comment": "如果for迭代声明中的第 1 个和第 3 个表达式为空，应改为 while 循环，使代码更简洁。",
        "tag": "control",
        "reference": "C++ Core Guidelines ES.73"
        },
    "ID_for_brace": {
        "checkPoint": "for 循环体应该用大括号括起来",
        "level": "suggestion",
        "comment": "for 循环体应为复合语句，即使只包含一条语句。",
        "tag": "control",
        "reference": "MISRA C 2004 14.8,MISRA C 2012 15.6,MISRA C++ 2008 6-3-1"
        },
    "ID_switch_invalidStatement": {
        "checkPoint": "switch 语句中任何子句都应从属于某个 case 或 default 分枝",
        "level": "error",
        "comment": "switch 语句中任何子句都应从属于某个 case 或 default 分枝，否则不会被执行。",
        "tag": "control",
        "reference": "CWE-561"
    },
    "ID_switch_identicalBranch": {
        "checkPoint": "不应存在内容完全相同的 case 分枝",
        "level": "warning",
        "comment": "内容完全相同的分枝应合并为一个分枝，也可能是由复制粘贴造成的错误。",
        "tag": "control",
        "config": {
            "ID_switch/identicalBranchThreshold": "重复分枝符号数量限制，不检查符号数量小于该值的分枝"
            },
        "related": "ID_if_identicalBlock,ID_if_identicalElseIfBlock",
        "reference": "C++ Core Guidelines ES.3"
    },
    "ID_switch_breakOmitted": {
        "checkPoint": "switch 语句的每个非空分枝都应该用无条件的 break 语句终止",
        "level": "warning",
        "comment": "每个非空分枝都应该用无条件的 break 语句终止，break 语句的缺失或误用是导致错误的常见原因。",
        "tag": "control",
        "standard": "ISO/IEC 14882:2017 10.6.5",
        "reference": "CWE-484,C++ Core Guidelines ES.78,MISRA C 2004 15.2,MISRA C 2012 16.3,MISRA C++ 2008 6-4-5"
    },
    "ID_switch_semicolon": {
        "checkPoint": "switch 语句不应被分号隔断",
        "level": "error",
        "comment": "switch 语句不应被分号隔断。",
        "tag": "control",
        "reference": "CWE-670"
        },
    "ID_switch_emptyBlock": {
        "checkPoint": "switch 语句不应为空",
        "level": "warning",
        "comment": "空的 switch 语句没有意义。",
        "tag": "control",
        "reference": "CWE-1071"
        },
    "ID_switch_bool": {
        "checkPoint": "switch 语句的条件变量或表达式不应为 bool 型",
        "level": "warning",
        "comment": "switch 语句的条件表达式为bool型时不应采用 switch 语句，应采用 if-else 语句。",
        "tag": "control",
        "reference": "MISRA C 2004 15.4,MISRA C 2012 16.7,MISRA C++ 2008 6-4-7"
        },
    "ID_switch_badFormedCase": {
        "checkPoint": "case 和 default 标签应直接从属于 switch 语句",
        "level": "suggestion",
        "comment": "不直接从属于 switch 语句的 case 或 default 标签用于非结构性跳转，是公认的不良实现。",
        "tag": "control",
        "related": "ID_forbidGotoBlocks",
        "reference": "MISRA C 2004 15.1,MISRA C++ 2008 6-4-4"
        },
    "ID_switch_missingDefault": {
        "checkPoint": "switch 语句应配有 default 分枝",
        "level": "suggestion",
        "comment": "所有 switch 语句都配有 default 分枝是非常好的编程习惯，这与 if...else-if 分枝要求有 else 分枝一样，是“防御性编程”思想的良好体现，参见 ID_if_missingEndingElse。",
        "tag": "control",
        "related": "ID_if_missingEndingElse",
        "reference": "CWE-478,MISRA C++ 2008 6-4-6"
        },
    "ID_try_emptyBlock": {
        "checkPoint": "不应存在空的 try 块",
        "level": "warning",
        "comment": "空的 try 块是毫无意义的，有可能是残留代码或功能未实现。",
        "tag": "control",
        "reference": "CWE-1071"
        },
    "ID_catch_emptyBlock": {
        "checkPoint": "不应存在空的 catch 块",
        "level": "suggestion",
        "comment": "空的 catch 块掩盖了异常，不利于问题的排查与纠正，应至少添加日志记录等操作。",
        "tag": "control",
        "reference": "CWE-1069,CWE-1071,CWE-391"
        },
    "ID_literal_misspelling": {
        "checkPoint": "字符串常量中不应存在拼写错误",
        "level": "warning",
        "comment": "如果含有拼写错误的常量字符串对用户可见，也可以认为是产品的一种 bug，会对用户造成困扰，故应认真对待。",
        "tag": "literal",
        "related": "ID_misspelling,ID_macro_misspelling"
        },
    "ID_literal_suspiciousChar": {
        "checkPoint": "注意可疑的字符常量",
        "level": "warning",
        "comment": "注意字符常量的错误书写，如正反斜杠的误用，'\\n' 误写为 '/n'、'\\\\' 误写为 '//'等。",
        "tag": "literal",
        "related": "ID_literal_multicharacter",
        "standard": "ISO/IEC 14882:2011 2.13.2(1)-implementation,ISO/IEC 14882:2011 2.14.3(1)-implementation,ISO/IEC 14882:2017 5.13.3(2)-implementation"
        },
    "ID_literal_hardCodeChar": {
        "checkPoint": "字符常量中不可存在应转义而未转义的字符",
        "level": "warning",
        "comment": "在字符常量中，如果存在制表符（tab）或回车、换行、控制等特殊字符，应使用转义字符。",
        "tag": "literal",
        "related": "ID_literal_hardCodeString"
        },
    "ID_literal_hardCodeString": {
        "checkPoint": "字符串常量中不可存在应转义而未转义的字符",
        "level": "warning",
        "comment": "在字符串常量中，如果存在制表符（tab）或回车、换行、控制等特殊字符，应使用转义字符。",
        "tag": "literal",
        "related": "ID_literal_hardCodeChar"
        },
    "ID_hardcodedIP": {
        "checkPoint": "IP 地址不应写入代码",
        "level": "warning",
        "comment": "在代码中记录 IP 地址不利于维护和移植，也容易暴露产品的网络结构，属于安全隐患。",
        "tag": "security",
        "related": "ID_addressExposure"
        },
    "ID_literal_nonStandardEsc": {
        "checkPoint": "不应使用非标准转义字符",
        "level": "warning",
        "comment": "使用非标准转义字符会导致标准之外的问题，也很有可能是反斜杠忘了转义。",
        "tag": "literal",
        "standard": "ISO/IEC 14882:2003 2.13.2(3)-undefined,ISO/IEC 14882:2011 2.14.3(3)-implementation,ISO/IEC 14882:2017 5.13.3(7)-implementation",
        "reference": "MISRA C 2004 4.1,MISRA C++ 2008 2-13-1"
        },
    "ID_literal_hybridConcat": {
        "checkPoint": "不同前缀的字符串常量不可连接在一起",
        "level": "warning",
        "comment": "L、U、u、u8 等字符串前缀表示不同的类型，连接在一起会导致标准之外的问题。",
        "tag": "literal",
        "standard": "ISO/IEC 14882:2003 2.13.4(3)-undefined,ISO/IEC 14882:2011 2.14.5(13)-implementation",
        "reference": "MISRA C++ 2008 2-13-5"
        },
    "ID_literal_oddConcat": {
        "checkPoint": "小心遗漏逗号导致的非预期字符串连接",
        "level": "warning",
        "comment": "注意可能导致非预期结果的字符串连接，尤其在初始化列表中，小心逗号被遗漏。",
        "tag": "literal"
        },
    "ID_literal_forbidOct": {
        "checkPoint": "禁用 8 进制常量",
        "level": "suggestion",
        "comment": "8 进制不像 10 进制那样符合人们的常规思维，也不像 2 进制或 16 进制那样便于展示数据的存储格式，而且 C/C++ 中 8 进制表示法只是在数字前置 0，与十进制过于相似，易被误用。",
        "tag": "literal",
        "reference": "MISRA C 2004 7.1,MISRA C 2012 7.1,MISRA C++ 2008 2-13-2"
        },
    "ID_literal_confusingSuffix": {
        "checkPoint": "整数或浮点数常量的后缀应使用大写字母",
        "level": "warning",
        "comment": "整数或浮点数常量的后缀应使用大写字母，否则小写字母“l”极易与数字“1”混淆。",
        "tag": "literal",
        "reference": "C++ Core Guidelines NL.19,MISRA C 2012 7.3,MISRA C++ 2008 2-13-4"
        },
    "ID_literal_nonStandardSuffix": {
        "checkPoint": "整数或浮点数常量应使用标准后缀",
        "level": "suggestion",
        "comment": "整数常量后缀只应为 L、LL、UL、ULL，浮点数常量的后缀只应为 L、f 或 F，其他非标准后缀没有可移植性。",
        "tag": "literal",
        "related": "ID_literal_confusingSuffix",
        "standard": "ISO/IEC 14882:2003 2.14.2(2) 2.14.4(1),ISO/IEC 14882:2011 2.14.2(2) 2.14.4(1),ISO/IEC 14882:2017 5.13.2(2) 5.13.4(1)"
        },
    "ID_literal_magicNumber": {
        "checkPoint": "不应存在 magic number",
        "level": "suggestion",
        "comment": "对于直接出现在代码中的字面数值（magic number），建议改用具有适当名称的常量或枚举项表示。",
        "config": {
            "ID_literal/magicNumberDigitThreshold": "数字常量的位数上限，超过则报出"
            },
        "tag": "literal",
        "related": "ID_literal_magicString",
        "reference": "C++ Core Guidelines ES.45"
        },
    "ID_literal_magicString": {
        "checkPoint": "不应存在 magic string",
        "level": "suggestion",
        "comment": "对于直接出现在代码中的字符串常量（magic string），建议改用具有适当名称的常量表示。",
        "tag": "literal",
        "related": "ID_literal_magicNumber",
        "reference": "C++ Core Guidelines ES.45"
        },
    "ID_literal_multicharacter": {
        "checkPoint": "不应使用多字符常量",
        "level": "suggestion",
        "comment": "多字符常量形式上与字符串常量相似，但类型为整型，易被误用，而且不同编译器对这种常量的处理方式也有所不同，故建议禁用。",
        "tag": "literal",
        "standard": "ISO/IEC 14882:2011 2.13.2(1)-implementation,ISO/IEC 14882:2011 2.14.3(1)-implementation,ISO/IEC 14882:2017 5.13.3(2)-implementation",
        "related": "ID_literal_suspiciousChar"
        },
    "ID_nonStdDirective": {
        "checkPoint": "不应使用非标准预编译指令",
        "level": "warning",
        "comment": "使用非标准预编译指令并非是问题的正规解决方法，且易造成代码移植方面的隐患。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10(1),ISO/IEC 9899:2011 6.10(1)",
        "reference": "MISRA C 2004 19.16,MISRA C 2012 20.13"
        },
    "ID_illFormedDirective": {
        "checkPoint": "不应出现非标准格式的预编译指令",
        "level": "warning",
        "comment": "非标准格式的预编译指令往往意味着错误，也会导致标准未定义的问题。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:2011 6.10(1),ISO/IEC 9899:2011 6.10.1(4)-undefined,ISO/IEC 14882:2011 16.1(4)-undefined",
        "reference": "MISRA C++ 2008 16-0-7,MISRA C++ 2008 16-0-8,MISRA C++ 2008 16-1-1"
        },
    "ID_warningDisabled": {
        "checkPoint": "对编译警告的屏蔽应慎重",
        "level": "suggestion",
        "comment": "编译器一般允许使用预编译指令屏蔽某些编译警告，但对于反映风险或安全问题的警告不应屏蔽。",
        "tag": "precompile",
        "related": "ID_warningDefault",
        "reference": "SEI CERT MSC00-C"
        },
    "ID_warningDefault": {
        "checkPoint": "在高级别的警告设置下编译",
        "level": "suggestion",
        "comment": "编译器一般允许设定编译警告的级别，级别越高关注的问题就越多，也可以将警告设为错误，当有警告产生时停止编译，建议代码在高级别的警告设置下编译。",
        "tag": "precompile",
        "related": "ID_warningDisabled",
        "reference": "SEI CERT MSC00-C"
        },
    "ID_macro_badName": {
        "checkPoint": "宏应遵循合理的命名方式",
        "level": "suggestion",
        "comment": "宏的名称应采用全大写字母的形式，非宏名称则应包含小写字母。",
        "config": {
            "ID_macro/maxWordLength": "连续无大小写变化的字符个数上限，超过则报出"
            },
        "tag": "precompile",
        "related": "ID_badName",
        "reference": "C++ Core Guidelines ES.32,C++ Core Guidelines ES.9"
        },
    "ID_macro_misspelling": {
        "checkPoint": "宏名称中不应存在拼写错误",
        "level": "suggestion",
        "comment": "宏的名称不应存在拼写错误，尤其是供他人调用的宏，错误拼写会使代码的使用者对代码的质量产生疑虑，故须认真对待。",
        "tag": "precompile",
        "related": "ID_misspelling,ID_literal_misspelling"
        },
    "ID_macro_tooManyParams": {
        "checkPoint": "宏参数数量应在规定范围之内",
        "level": "warning",
        "comment": "宏参数数量过多意味着宏功能过于复杂，不利于调试，应改为函数。",
        "config": {
            "ID_macro/maxParamCount": "参数个数上限，超过则报出"
            },
        "related": "ID_tooManyParams",
        "tag": "precompile"
        },
    "ID_macro_insufficientArgs": {
        "checkPoint": "宏的实参个数不可小于形参个数",
        "level": "warning",
        "comment": "宏的实参个数小于形参个数是不符合 C/C++ 标准的，参数个数不一致必然意味着某种错误，然而在某些编译环境下却可以通过编译。",
        "tag": "precompile",
        "related": "ID_macro_redundantArgs",
        "reference": "CWE-628,MISRA C 2004 19.8"
        },
    "ID_macro_redundantArgs": {
        "checkPoint": "宏的实参个数不可大于形参个数",
        "level": "warning",
        "comment": "宏的实参个数大于形参个数是不符合 C/C++ 标准的，参数个数不一致必然意味着某种错误，然而在某些编译环境下却可以通过编译。",
        "tag": "precompile",
        "related": "ID_macro_insufficientArgs",
        "reference": "CWE-628"
        },
    "ID_macro_sideEffectArgs": {
        "checkPoint": "宏参数不应有副作用",
        "level": "warning",
        "comment": "当宏参数有“副作用（side effect）”时，如果宏定义中没有或多次引用到该参数，会导致意料之外的错误。",
        "tag": "precompile",
        "related": "ID_sideEffectAssertion,ID_macro_function",
        "reference": "SEI CERT PRE31-C"
        },
    "ID_macro_paramNotEnclosed": {
        "checkPoint": "与运算符相关的宏参数应该用括号括起来",
        "level": "warning",
        "comment": "由于宏只做文本处理，不考虑运算符优先级等问题，故应将宏参数用括号括起来，否则很可容易产生意料之外的错误。",
        "tag": "precompile",
        "reference": "CWE-783,MISRA C++ 2008 16-0-6"
        },
    "ID_macro_expNotEnclosed": {
        "checkPoint": "可作为子表达式的宏定义应该用括号括起来",
        "level": "warning",
        "comment": "由于宏只做文本处理，不考虑运算符优先级等问题，可作为子表达式的宏定义应该用括号括起来，否则很可容易产生意料之外的错误。",
        "tag": "precompile",
        "reference": "CWE-783,MISRA C 2004 19.10,MISRA C 2012 20.7"
        },
    "ID_macro_stmtNotEnclosed": {
        "checkPoint": "由多个语句组成的宏定义应该用 do-while(0) 括起来",
        "level": "warning",
        "comment": "可以作为一条语句使用的宏，且宏包含多个并列子句时，应该用“do {”和 “} while(0)”括起来，否则易造成作用域的混乱。",
        "tag": "precompile",
        "related": "ID_if_scope,ID_while_scope,ID_for_scope",
        "reference": "CWE-483"
        },
    "ID_macro_defineReserved": {
        "checkPoint": "不可定义具有保留意义的宏名称",
        "level": "warning",
        "comment": "重新定义已有特殊用途的名称，会使代码陷入难以维护的境地，也会导致标准未定义的问题。",
        "config": { "//": "详见说明" },
        "tag": "precompile",
        "standard": "ISO/IEC 9899:2011 7.1.3(2)-undefined,ISO/IEC 14882:2011 16.8(4)-undefined",
        "related": "ID_macro_undefReserved,ID_reservedName",
        "reference": "MISRA C 2012 21.1,MISRA C 2012 20.4,MISRA C++ 2008 17-0-1"
        },
    "ID_macro_undefReserved": {
        "checkPoint": "不可取消定义具有保留意义的宏名称",
        "level": "warning",
        "comment": "取消定义已有特殊用途的宏名称，会使代码陷入难以维护的境地，也会导致标准未定义的问题。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:2011 7.1.3(3)-undefined,ISO/IEC 14882:2011 16.8(4)-undefined",
        "related": "ID_macro_defineReserved,ID_reservedName",
        "reference": "MISRA C 2012 21.1,MISRA C 2012 20.5,MISRA C++ 2008 17-0-1,MISRA C++ 2008 16-0-3"
        },
    "ID_macro_complexConcat": {
        "checkPoint": "在宏定义中由 # 修饰的参数后不应出现 ##",
        "level": "warning",
        "comment": "不同编译器对 # 和 ## 的优先级有不同的实现，在有可移植性要求的代码中不应嵌套使用，而且 ## 连接的单词数量不应超过两个。",
        "tag": "precompile",
        "standard": "ISO/IEC 14882:2003 16.3.2(2)-unspecified,ISO/IEC 14882:2003 16.3.3(3)-unspecified,ISO/IEC 14882:2011 16.3.2(2)-unspecified,ISO/IEC 14882:2011 16.3.3(3)-unspecified,ISO/IEC 14882:2017 19.3.2(2)-unspecified,ISO/IEC 14882:2017 19.3.3(3)-unspecified",
        "reference": "MISRA C 2004 19.12,MISRA C 2012 20.11,MISRA C++ 2008 16-3-1"
        },
    "ID_macro_const": {
        "checkPoint": "不应使用宏定义常量",
        "level": "suggestion",
        "comment": "宏用于文本处理，不受作用域等语言规则限制，不应使用宏实现常量等语言层面的概念。",
        "tag": "precompile",
        "related": "ID_macro_typeid,ID_macro_function",
        "reference": "C++ Core Guidelines ES.31,C++ Core Guidelines Enum.1"
        },
    "ID_macro_typeid": {
        "checkPoint": "不应使用宏定义类型",
        "level": "suggestion",
        "comment": "宏用于文本处理，不受作用域等语言规则限制，不应使用宏实现类型等语言层面的概念。",
        "tag": "precompile",
        "related": "ID_macro_sideEffectArgs,ID_macro_const,ID_macro_function",
        "reference": "C++ Core Guidelines ES.30"
        },
    "ID_macro_function": {
        "checkPoint": "可由函数实现的功能不应使用宏实现",
        "level": "suggestion",
        "comment": "宏用于文本处理，不受作用域、参数传递、重载等语言规则限制，可由函数实现的功能不应使用宏实现。",
        "tag": "precompile",
        "related": "ID_macro_sideEffectArgs,ID_macro_const,ID_macro_typeid",
        "reference": "C++ Core Guidelines ES.31,MISRA C 2004 19.7,MISRA C 2012 Dir 4.9,MISRA C++ 2008 16-0-4"
        },
    "ID_functionRepetition": {
        "checkPoint": "不应存在重复的函数实现",
        "level": "suggestion",
        "comment": "不同的函数代码却完全相同或过于相似是不利于维护的。",
        "tag": "function",
        "reference": "CWE-1041,C++ Core Guidelines ES.3"
        },
    "ID_invalidCondition": {
        "checkPoint": "条件表达式不应恒为真或恒为假",
        "level": "warning",
        "comment": "变量初始化后不经修改即作为条件往往意味着某种逻辑错误。",
        "tag": "expression",
        "related": "ID_constLogicExpression",
        "reference": "CWE-570,CWE-571,MISRA C 2004 13.7,MISRA C 2012 14.3"
        },
    "ID_nullDerefInExp": {
        "checkPoint": "注意逻辑表达式内的空指针解引用",
        "level": "error",
        "comment": "在逻辑表达式中，判断指针是否为空的子表达式可以作为指针解引用的条件，需注意其逻辑关系及运算符优先级，不可出现空指针解引用的问题。",
        "tag": "pointer",
        "standard": "ISO/IEC 9899:1999 6.5.3.2(4)-undefined,ISO/IEC 9899:2011 6.5.3.2(4)-undefined",
        "reference": "CWE-476,CWE-783,C++ Core Guidelines ES.65"
        },
    "ID_nullDerefInScp": {
        "checkPoint": "避免空指针解引用",
        "level": "error",
        "comment": "解引用空指针会导致程序崩溃等标准未定义的错误。",
        "tag": "pointer",
        "standard": "ISO/IEC 9899:1999 6.5.3.2(4)-undefined,ISO/IEC 9899:2011 6.5.3.2(4)-undefined",
        "reference": "CWE-476,C++ Core Guidelines ES.65"
        },
    "ID_divideByZero": {
        "checkPoint": "除数不可存在值为 0 的可能性",
        "level": "error",
        "comment": "除数为 0 会导致标准未定义的错误。",
        "tag": "security",
        "standard": "ISO/IEC 9899:1999 6.5.5(5)-undefined,ISO/IEC 9899:2011 6.5.5(5)-undefined,ISO/IEC 14882:2011 5.6(4)-undefined,ISO/IEC 14882:2017 8.6(4)-undefined",
        "reference": "CWE-369,C++ Core Guidelines ES.105"
        },
    "ID_nullDerefAllocRet": {
        "checkPoint": "判断 malloc 等函数的返回值是否为空",
        "level": "warning",
        "comment": "malloc 等函数在分配失败时返回空指针，如果不加判断直接解引用会造成标准未定义的错误。",
        "tag": "pointer",
        "standard": "ISO/IEC 9899:1999 7.20.3(1),ISO/IEC 9899:2011 7.22.3(1)",
        "reference": "CWE-476,CWE-252"
        },
    "ID_nullDerefDynamicCast": {
        "checkPoint": "判断 dynamic_cast 转换是否成功",
        "level": "warning",
        "comment": "dynamic_cast 转换指针失败会返回空指针，转换引用失败会抛出异常，如果不作判断则失去了使用 dynamic_cast 的意义。",
        "tag": "pointer",
        "standard": "ISO/IEC 14882:2011 5.2.7(9)",
        "related": "ID_nonDynamicDownCast",
        "reference": "CWE-476,C++ Core Guidelines C.148"
        },
    "ID_danglingDeref": {
        "checkPoint": "不可解引用已被释放的指针",
        "level": "error",
        "comment": "已经被释放的指针指向无效的内存空间，如果再次对其解引用会造成标准未定义的错误。",
        "tag": "pointer",
        "related": "ID_illAccess",
        "standard": "ISO/IEC 9899:1999 6.5.3.2(4)-undefined,ISO/IEC 9899:2011 6.5.3.2(4)-undefined",
        "reference": "CWE-822,CWE-825,C++ Core Guidelines ES.65"
        },
    "ID_sensitiveName": {
        "checkPoint": "公共成员或全局对象不应记录敏感数据",
        "level": "warning",
        "comment": "公共成员、全局对象可被外部代码引用，如果存有敏感数据则可能会被误用或窃取。",
        "tag": "security",
        "reference": "CWE-766"
        },
    "ID_dangerousName": {
        "checkPoint": "不应引用危险符号名称",
        "level": "warning",
        "comment": "弱加密、弱哈希、弱随机、不安全的协议等相关库、函数、类、宏、常量等名称不应出现在代码中。",
        "tag": "security",
        "config": { "//": "详见说明" },
        "reference": "CWE-326,CWE-327"
        },
    "ID_badLength": {
        "checkPoint": "memset 等函数长度相关的参数不应有误",
        "level": "error",
        "comment": "对于 memset、memcpy、memmove、memcmp 及同类函数，表示长度的参数不应存在常见笔误。",
        "tag": "buffer",
        "reference": "CWE-130,CWE-805"
        },
    "ID_valueOverflow": {
        "checkPoint": "memset 等函数填充值相关的参数不应有误",
        "level": "error",
        "comment": "memset、memset_s 等函数的填充值参数会被转为 unsigned char 型，所以其值不应超出一个字节的范围。",
        "tag": "buffer",
        "standard": "ISO/IEC 9899:2011 7.24.6.1(2),ISO/IEC 9899:2011 K.3.7.4.1(4)",
        "reference": "CWE-130"
        },
    "ID_qualifierInvalid": {
        "checkPoint": "const、volatile 不可修饰引用",
        "level": "error",
        "comment": "C++标准规定，const 或 volatile 可修饰指针，但不可修饰引用，否则起不到任何作用。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 8.3.2(1),ISO/IEC 14882:2011 8.3.2(1),ISO/IEC 14882:2017 11.3.2(1)"
        },
    "ID_qualifierForPtrAlias": {
        "checkPoint": "const、volatile 修饰指针类型的别名是可疑的",
        "level": "suspicious",
        "comment": "如果const、volatile 修饰指针类型的别名，很可能会造成意料之外的问题。",
        "tag": "declaration",
        "related": "ID_qualifierInvalid",
        "reference": "SEI CERT DCL05-C"
        },
    "ID_qualifierRepeated": {
        "checkPoint": "const、volatile 不应重复",
        "level": "error",
        "comment": "重复的 const 或 volatile 限定符是没意义的，也可能意味着某种错误。",
        "tag": "declaration",
        "related": "ID_badQualifierPosition"
        },
    "ID_forbidVolatile": {
        "checkPoint": "慎用 volatile 关键字",
        "level": "suggestion",
        "comment": "对于硬件无关的功能性代码不妨禁用 volatile 关键字，否则误用该关键字会引发优化及同步相关的多种问题。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 7.1.5.1(8),ISO/IEC 14882:2011 7.1.6.1(7)",
        "reference": "C++ Core Guidelines CP.8,C++ Core Guidelines CP.200"
        },
    "ID_sizeof_arrayParameter": {
        "checkPoint": "对数组参数不应使用 sizeof",
        "level": "error",
        "comment": "当函数的形式参数为数组时，实际上是一个指针，对这种参数使用 sizeof 无法获取到数组大小，往往意味着错误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.7.5.3(7),ISO/IEC 9899:2011 6.7.6.3(7)",
        "reference": "CWE-467"
        },
    "ID_sizeof_zeroComparison": {
        "checkPoint": "sizeof 的结果不应与 0 以及负数比较",
        "level": "error",
        "comment": "标准规定，sizeof 的结果为无符号整型，对于完整类型结果一定不为 0，对于不完整类型则无法通过编译，所以将 sizeof 的结果与 0 甚至负数比较往往意味着逻辑错误。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2003 5.3.3(1 6) 9(3),ISO/IEC 14882:2011 5.3.3(1 6) 9(3),ISO/IEC 14882:2017 8.3.3(1 6) 12(4)",
        "reference": "CWE-1025"
        },
    "ID_sizeof_sizeof": {
        "checkPoint": "sizeof 不应再作用于 sizeof",
        "level": "error",
        "comment": "sizeof(sizeof(....)) 等价于 sizeof(size_t)，在实际应用中没有任何必要写成连续 sizeof 的形式，属于常见笔误，多数由复制粘贴或错误的宏展开导致。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2003 5.3.3(6),ISO/IEC 14882:2011 5.3.3(6),ISO/IEC 14882:2017 8.3.3(6)",
        "reference": "CWE-682"
        },
    "ID_sizeof_sideEffect": {
        "checkPoint": "sizeof 不应作用于有副作用的表达式",
        "level": "warning",
        "comment": "sizeof 只关注类型，其子表达式不会被求值，如果存在可以影响程序状态的运算符或函数调用，也不会有实际效果。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2003 5.3.3(1),ISO/IEC 14882:2011 5.3.3(1),ISO/IEC 14882:2017 8.3.3(1)",
        "reference": "SEI CERT EXP52-CPP,MISRA C 2004 12.3,MISRA C 2012 13.6,MISRA C++ 2008 5-3-4"
        },
    "ID_sizeof_NULL": {
        "checkPoint": "C++ 代码中 sizeof 不应作用于 NULL",
        "level": "warning",
        "comment": "在 C++ 语言中，标识符 NULL 并不能有效区分整型常量 0 和空指针，sizeof(NULL) 一类的表达式预期是获取指针变量的大小，而实际结果可能是整型变量的大小。",
        "tag": "expression",
        "related": "ID_deprecatedNULL",
        "standard": "ISO/IEC 9899:1999 7.17(3)-implementation,ISO/IEC 9899:2011 7.19(3)-implementation,ISO/IEC 14882:2003 C.2.2.3(1)-implementation,ISO/IEC 14882:2011 C.3.2.4(1)-implementation,ISO/IEC 14882:2017 C.5.2.7(1)-implementation",
        "reference": "CWE-351"
        },
    "ID_sizeof_pointer": {
        "checkPoint": "sizeof 作用于指针是可疑的",
        "level": "suspicious",
        "comment": "sizeof 作用于指针获取到的是指针变量的大小，而不是指针指向内容的大小，sizeof 作用于指针很容易造成错误。",
        "tag": "pointer",
        "related": "ID_sizeof_pointerDivision",
        "reference": "CWE-467"
        },
    "ID_accessPaddingData": {
        "checkPoint": "不应访问填充数据",
        "level": "warning",
        "comment": "变量之间可能存在填充数据，这种数据只为实现“内存对齐”而无数值意义，而且填充数据的值是标准未声明的。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:2011 6.2.6.2(5)-unspecified"
        },
    "ID_wrongUseOfReturnValue": {
        "checkPoint": "不可臆断返回值的意义",
        "level": "error",
        "comment": "对接口的使用应遵循接口文档，不可臆断返回值的意义，否则造成逻辑错误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 7.21.4,ISO/IEC 9899:2011 7.24.4",
        "reference": "CWE-253"
        },
    "ID_inconsistentFormatArgNum": {
        "checkPoint": "C 风格的格式化字符串与其参数的个数应严格一致",
        "level": "error",
        "comment": "对于 C 风格的格式化函数（如 printf、fprintf、sprintf 等），格式化字符串与其对应参数的个数应严格一致，否则会引发严重的运行时堆栈错误。",
        "tag": "expression",
        "related": "ID_inconsistentFormatArgType,ID_forbidCStringFormat",
        "standard": "ISO/IEC 9899:2011 7.16.1.1(2)-undefined,ISO/IEC 9899:2011 7.21.6.1(2)-undefined",
        "reference": "SEI CERT FIO47-C"
        },
    "ID_inconsistentFormatArgType": {
        "checkPoint": "C 风格的格式化字符串与其参数的类型应严格一致",
        "level": "error",
        "comment": "对于 C 风格的格式化函数（如 printf、fprintf、sprintf 等），格式化字符串与其对应参数的类型应严格一致，否则会引发严重的运行时堆栈错误。",
        "tag": "expression",
        "related": "ID_userObjectAsVariadicArgument,ID_inconsistentFormatArgNum,ID_forbidCStringFormat",
        "standard": "ISO/IEC 9899:2011 7.16.1.1(2)-undefined,ISO/IEC 9899:2011 7.21.6.1(2)-undefined",
        "reference": "CWE-686,SEI CERT FIO47-C"
        },
    "ID_variableFormatString": {
        "checkPoint": "格式化字符串应为常量",
        "level": "warning",
        "comment": "出于可读性和安全性的考量，格式化字符串最好直接写成常量字符串的形式。",
        "tag": "security",
        "related": "ID_hijack",
        "reference": "CWE-134"
        },
    "ID_addressExposure": {
        "checkPoint": "与程序实现相关的信息不可被外界感知",
        "level": "warning",
        "comment": "函数或对象的地址、缓冲区的地址和长度等信息不可被外界感知，否则会成为攻击者的线索。",
        "tag": "security",
        "related": "ID_hardcodedIP",
        "reference": "CWE-200"
        },
    "ID_forbidCStringFormat": {
        "checkPoint": "在 C++ 代码中禁用 C 风格字符串格式化方法",
        "level": "suggestion",
        "comment": "C 风格字符串格式化方法（如 printf、sprintf 等），即由可变参数列表实现的格式化方法是不安全的，在编译期无法限定参数的类型和数量，极易产生各种错误。",
        "tag": "expression",
        "related": "ID_forbidVariadicFunction",
        "standard": "ISO/IEC 9899:2011 7.16.1.1(2)-undefined,ISO/IEC 9899:2011 7.21.6.1(2)-undefined",
        "reference": "C++ Core Guidelines SL.io.3"
        },
    "ID_this_zeroComparison": {
        "checkPoint": "不应判断 this 指针是否为空",
        "level": "warning",
        "comment": "正常情况下 this 指针不会为空，而且判断 this 指针是否为空会影响编译器对 this 指针的优化，造成难以预料的后果。",
        "tag": "pointer",
        "standard": "ISO/IEC 14882:2003 4.1(1),ISO/IEC 14882:2011 4.1(1)",
        "reference": "CWE-1025"
        },
    "ID_illMemberAccess": {
        "checkPoint": "在面向构造或析构函数体的 catch 块中不可访问非静态成员",
        "level": "error",
        "comment": "当流程进入面向构造或析构函数体的 catch 块时，非静态成员的生命周期已经结束，如果再次访问会导致标准未定义的错误。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2011 15.3(10)-undefined",
        "reference": "MISRA C++ 2008 15-3-3"
        },
    "ID_this_selfJudgement": {
        "checkPoint": "赋值运算符应妥善处理参数就是自身对象时的情况",
        "level": "warning",
        "comment": "赋值运算符应妥善处理参数就是自身对象时的情况，防止资源分配或回收的冲突。",
        "tag": "function",
        "reference": "C++ Core Guidelines C.62"
        },
    "ID_this_deleteInDestructor": {
        "checkPoint": "析构函数中不可使用 delete this",
        "level": "error",
        "comment": "析构函数中不可使用 delete this，否则造成无限递归。",
        "tag": "pointer",
        "reference": "CWE-674"
        },
    "ID_this_forbidDeleteThis": {
        "checkPoint": "禁用 delete this",
        "level": "suggestion",
        "comment": "因为正确使用 delete this 限制条件太多，稍不留意就会为 bug 埋下伏笔，所以禁用这种方式是明智的选择。",
        "tag": "pointer"
        },
    "ID_deprecatedSpecifier": {
        "checkPoint": "不应使用已过时的关键字",
        "level": "warning",
        "comment": "根据 C++11 标准，register 等关键字已过时，不应再使用，auto 关键字也不可再作为存储类说明符（storage class specifier）继续使用。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2011 D.2(1)-deprecated,ISO/IEC 14882:2011 7.1.6.4"
        },
    "ID_inlineRedundant": {
        "checkPoint": "不应使用多余的 inline 关键字",
        "level": "suggestion",
        "comment": "constexpr 关键字修饰的函数已经相当于被声明为 inline，不应再重复声明。",
        "standard": "ISO/IEC 14882:2011 7.1.5(2)",
        "tag": "declaration"
        },
    "ID_badName": {
        "checkPoint": "遵循合理的命名方式",
        "level": "suggestion",
        "comment": "应遵循易于读写，并可准确表达代码意图的命名方式。",
        "config": {
            "ID_declaration/maxWordLength": "连续无大小写变化的字符个数上限，超过则报出"
            },
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 5.2.4.1(1),ISO/IEC 9899:1999 6.4.2.1(6)-undefined,ISO/IEC 9899:2011 5.2.4.1(1),ISO/IEC 9899:2011 6.4.2.1(6)-undefined",
        "reference": "C++ Core Guidelines NL.19,C++ Core Guidelines ES.8,MISRA C 2004 5.1,MISRA C 2012 5.1"
        },
    "ID_reservedName": {
        "checkPoint": "不应定义具有保留意义的名称",
        "level": "suggestion",
        "comment": "自定义的名称不应与关键字、标准库或系统中的名称重复，否则极易造成阅读和维护上的困扰。",
        "tag": "declaration",
        "related": "ID_macro_defineReserved,ID_macro_undefReserved",
        "standard": "ISO/IEC 9899:2011 7.1.3(1)",
        "reference": "SEI CERT DCL37-C,SEI CERT DCL51-CPP,MISRA C 2012 21.2,MISRA C++ 2008 17-0-1,MISRA C++ 2008 17-0-2,MISRA C++ 2008 17-0-3"
        },
    "ID_duplicatedName": {
        "checkPoint": "类型名称不应与对象或函数名称相同",
        "level": "suggestion",
        "comment": "如果不同的代码元素使用相同的名称，极易造成困扰。",
        "tag": "declaration",
        "reference": "MISRA C++ 2008 2-10-6"
        },
    "ID_misspelling": {
        "checkPoint": "不应存在拼写错误",
        "level": "suggestion",
        "comment": "代码中不应存在拼写错误，尤其是供他人调用的代码，如命名空间名称、类的公有成员名称，全局函数名称等，更不应存在拼写错误。",
        "tag": "declaration"
        },
    "ID_mixNullptrAndNULL": {
        "checkPoint": "NULL 和 nullptr 不应混用",
        "level": "warning",
        "comment": "NULL 和 nullptr 不应混用，应统一使用 nullptr。",
        "tag": "style",
        "related": "ID_deprecatedNULL",
        "reference": "C++ Core Guidelines ES.47"
        },
    "ID_deprecatedNULL": {
        "checkPoint": "在 C++ 代码中不应使用 NULL，应使用 nullptr",
        "level": "suggestion",
        "comment": "在 C++ 语言中，标识符 NULL 虽然可以用来表示空指针，但该标识符是由实现定义的，而且往往不能有效区分整型常量 0 和空指针，根据 C++11 标准，应使用 nullptr 表示空指针。",
        "tag": "style",
        "standard": "ISO/IEC 9899:1999 7.17(3)-implementation,ISO/IEC 9899:2011 7.19(3)-implementation,ISO/IEC 14882:2003 C.2.2.3(1)-implementation,ISO/IEC 14882:2011 C.3.2.4(1)-implementation,ISO/IEC 14882:2017 C.5.2.7(1)-implementation,ISO/IEC 14882:2011 2.14.7(1)",
        "reference": "C++ Core Guidelines ES.47"
        },
    "ID_deprecatedOffsetof": {
        "checkPoint": "在 C++ 代码中不应使用宏 offsetof",
        "level": "suggestion",
        "comment": "宏 offsetof 很难适用于具有 C++ 特性的类，易引发未定义的错误。",
        "tag": "precompile",
        "standard": "ISO/IEC 14882:2003 18.1(5),ISO/IEC 14882:2011 18.2(4),ISO/IEC 14882:2017 21.2.4(1)"
        },
    "ID_forbidReinterpretCast": {
        "checkPoint": "使用 reinterpret_cast 需有文档说明",
        "level": "suggestion",
        "comment": "语言对 reinterpret_cast 的定位不是为了安全性，而是为了灵活性，可以用其他方式实现的功能不可使用 reinterpret_cast，如果必须使用需有明确文档说明。",
        "tag": "cast",
        "related": "ID_forbidCStyleCast",
        "reference": "CWE-843,C++ Core Guidelines Pro.safety"
        },
    "ID_sizeof_suspiciousAdd": {
        "checkPoint": "指针加减偏移量时计入 sizeof 是可疑的",
        "level": "suspicious",
        "comment": "指针加减偏移量时会自动计入指针指向类型的大小，如果再计入 sizeof 的值，很可能是某种错误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.5.6(8),ISO/IEC 9899:2011 6.5.6(8)",
        "reference": "CWE-468"
        },
    "ID_insufficientBuffer": {
        "checkPoint": "为缓冲区分配足够的空间",
        "level": "warning",
        "comment": "为缓冲区分配足够的空间，避免溢出等问题。",
        "tag": "buffer",
        "related": "ID_bufferOverflow",
        "reference": "CWE-131,CWE-135"
        },
    "ID_assignmentAsSubExpression": {
        "checkPoint": "赋值表达式不应作为子表达式",
        "level": "suggestion",
        "comment": "赋值表达式作为子表达式增加了复杂性，且容易产生优先级相关的问题。",
        "tag": "style",
        "reference": "CWE-481,MISRA C 2004 13.1,MISRA C 2012 13.4,MISRA C++ 2008 6-2-1"
        },
    "ID_secretLeak": {
        "checkPoint": "敏感数据不可被系统外界感知",
        "level": "warning",
        "comment": "敏感数据出入软件系统时需采用有效的保护措施。",
        "tag": "security",
        "related": "ID_unsafeCleanup",
        "reference": "CWE-528,CWE-591,SEI CERT MEM06-C,SEI CERT MEM06-CPP"
        },
    "ID_unsafeCleanup": {
        "checkPoint": "敏感数据在使用后应被有效清理",
        "level": "warning",
        "comment": "及时清理不再使用的敏感数据是重要的安全措施，且应保证清理过程不会因为编译器的优化而失效。",
        "tag": "security",
        "standard": "ISO/IEC 9899:2011 5.1.2.3(4),ISO/IEC 9899:2011 K.3.7.4.1",
        "related": "ID_secretLeak,ID_forbidVolatile",
        "reference": "CWE-14,CWE-733,SEI CERT MSC06-C"
        },
    "ID_nonConstNonStaticGlobalObject": {
        "checkPoint": "全局对象只应为常量或静态对象",
        "level": "warning",
        "comment": "非常量全局对象破坏了面向对象的封装理念，如果必须使用全局对象，应将其限定在文件范围之内。",
        "tag": "global",
        "related": "ID_nonConstGlobalObject",
        "reference": "C++ Core Guidelines I.2,C++ Core Guidelines CP.3,C++ Core Guidelines R.6"
        },
    "ID_nonConstGlobalObject": {
        "checkPoint": "全局对象只应为常量",
        "level": "warning",
        "comment": "非常量全局对象与类的公有数据成员一样对外部的读写没有限制，破坏了面向对象的封装理念。",
        "tag": "global",
        "related": "ID_nonPrivateData",
        "reference": "C++ Core Guidelines I.2,C++ Core Guidelines CP.3,C++ Core Guidelines R.6"
        },
    "ID_forbidMemberVoidPtr": {
        "checkPoint": "类成员不应被声明为 void*",
        "level": "warning",
        "comment": "与接口相关的数据类型应保持精确，不应将类成员声明为 void*，尤其是非 private 成员，更不应声明为 void*。",
        "tag": "declaration",
        "related": "ID_forbidFunctionVoidPtr",
        "reference": "C++ Core Guidelines I.4"
        },
    "ID_forbidFunctionVoidPtr": {
        "checkPoint": "接口的参数或返回值不应被声明为 void*",
        "level": "warning",
        "comment": "与接口相关的数据类型应保持精确，不应将参数或返回值声明为 void*。",
        "tag": "declaration",
        "related": "ID_forbidMemberVoidPtr",
        "reference": "C++ Core Guidelines I.4"
        },
    "ID_improperNullTermination": {
        "checkPoint": "确保字符串以空字符结尾",
        "level": "warning",
        "comment": "语言要求字符串以空字符结尾，程序应保证有足够的内存空间安置空字符，否则会破坏程序基本的执行机制，造成严重问题。",
        "tag": "security",
        "standard": "ISO/IEC 9899:2011 7.24.2.4",
        "related": "ID_unsafeStringFunction",
        "reference": "CWE-170"
        },
    "ID_deprecatedErrno":  {
        "checkPoint": "避免使用 errno",
        "level": "warning",
        "comment": "正确使用 errno 需要注意很多繁琐的细节，极易误用。",
        "tag": "security",
        "reference": "MISRA C 2004 20.5,MISRA C++ 2008 19-3-1,C++ Core Guidelines E.28"
    },
    "ID_unsafeStringFunction": {
        "checkPoint": "禁用不安全的字符串函数",
        "level": "warning",
        "comment": "由于历史原因，C 语言某些字符串函数不检查缓冲区长度，易造成运行时错误或安全漏洞。",
        "tag": "security",
        "standard": "ISO/IEC 9899:2011 K.3.7",
        "related": "ID_bufferOverflow",
        "reference": "CWE-119,CWE-120,CWE-676,MISRA C++ 2008 18-0-5"
        },
    "ID_forbidAtox": {
        "checkPoint": "禁用 atof、atoi、atol 以及 atoll 等函数",
        "level": "warning",
        "comment": "当字符串无法被正确转为数值时，stdlib.h 或 cstdlib 中的 atof、atoi、atol 以及 atoll 等函数存在标准未定义的行为。",
        "tag": "security",
        "standard": "ISO/IEC 9899:1999 7.20.1(1)-undefined,ISO/IEC 9899:2011 7.22.1(1)-undefined",
        "reference": "CWE-190,MISRA C 2004 20.10,MISRA C 2012 21.7,MISRA C++ 2008 18-0-2"
        },
    "ID_forbidLongjmp": {
        "checkPoint": "禁用 setjmp、longjmp",
        "level": "warning",
        "comment": "setjmp、longjmp 可以在函数间跳转，进一步破坏了结构化编程理念，非框架代码不应使用。",
        "tag": "function",
        "standard": "ISO/IEC 9899:1999 7.13.2.1(2)-undefined,ISO/IEC 14882:2011 18.10(4)-undefined",
        "reference": "MISRA C 2004 20.7,MISRA C 2012 21.4,MISRA C++ 2008 17-0-5,C++ Core Guidelines SL.C.1"
        },
    "ID_obsoleteFunction": {
        "checkPoint": "不应调用已过时的函数",
        "level": "warning",
        "comment": "某些库函数或系统 API 存在缺陷并已宣布过时，应使用更完善的替代方法。",
        "tag": "security",
        "config": { "//": "详见说明" },
        "reference": "CWE-477"
        },
    "ID_dangerousFunction": {
        "checkPoint": "避免调用具有危险性的函数",
        "level": "warning",
        "comment": "某些库函数或系统 API 本身就具有危险性，使用这种函数相当于直接引入了风险。",
        "tag": "security",
        "config": { "//": "详见说明" },
        "reference": "CWE-242,CWE-474,CWE-676"
        },
    "ID_implementationDefinedFunction": {
        "checkPoint": "避免使用由实现定义的库函数",
        "level": "warning",
        "comment": "由实现定义的（implementation-defined）库函数存在语言标准之外的行为。",
        "tag": "security",
        "standard": "ISO/IEC 9899:2011 7.22.4.1(2)-implementation,ISO/IEC 9899:2011 7.22.4.4(5)-implementation,ISO/IEC 9899:2011 7.22.4.6(2)-implementation,ISO/IEC 9899:2011 7.22.4.8(3)-implementation,ISO/IEC 9899:2011 7.27.2.1(3)-implementation,ISO/IEC 9899:2011 7.14.1.1(3)-implementation",
        "reference": "MISRA C 2004 20.8,MISRA C 2004 20.11,MISRA C 2004 20.12,MISRA C 2012 21.5,MISRA C 2012 21.8,MISRA C 2012 21.10,MISRA C++ 2008 18-0-3,MISRA C++ 2008 18-0-4,MISRA C++ 2008 18-7-1"
        },
    "ID_missingVoid": {
        "checkPoint": "C 代码中函数参数列表如果为空须声明为“(void)”",
        "level": "warning",
        "comment": "在 C 语言中，如果函数的参数列表声明为空的括号，表示函数的参数还没有声明，而不是表示没有参数。这便引入了相当大的不确定性，为了减少混乱，没有参数的参数列表应声明为“(void)”。",
        "tag": "declaration",
        "related": "ID_superfluousVoid",
        "standard": "ISO/IEC 9899:2011 6.7.6.3(14),ISO/IEC 9899:2011 6.11.6(1)",
        "reference": "MISRA C 2004 16.5"
        },
    "ID_superfluousVoid": {
        "checkPoint": "C++ 代码中函数参数列表如果为空不应声明为“(void)”",
        "level": "suggestion",
        "comment": "与 C 语言不同，在 C++ 中如果函数的参数列表声明为空的括号，与声明为“(void)”的方式完全相同，均表示没有参数，所以如果在 C++ 仍采用 C 的声明方式就显得很啰嗦。",
        "tag": "declaration",
        "related": "ID_missingVoid",
        "standard": "ISO/IEC 14882:2003 C.1.6 Clause 8,ISO/IEC 14882:2011 C.1.7 Clause 8,ISO/IEC 14882:2017 C.1.7 Clause 11",
        "reference": "C++ Core Guidelines NL.25"
        },
    "ID_missingResetNull": {
        "checkPoint": "指针在释放后应置空",
        "level": "suggestion",
        "comment": "指针指向的动态内存空间被回收后指针不再有效，这时应将指针设为空指针，可避免重复释放造成的问题，如果后续对指针仍有错误的读写，也可使问题立即显现出来，不至于造成难以排查的问题。",
        "tag": "pointer",
        "related": "ID_danglingDeref,ID_explicitDtorCall",
        "reference": "SEI CERT MEM01-C"
        },
    "ID_unlimitedAuthority": {
        "checkPoint": "对文件设定合理的权限",
        "level": "warning",
        "comment": "文件的访问权限不可过于宽松，否则很容易遭到窃取或篡改。",
        "tag": "security",
        "standard": "ISO/IEC 9899:2011 K.3.5.2.1(7),ISO/IEC 14882:2017 30.10.15.26",
        "reference": "CWE-266,CWE-732,SEI CERT FIO06-C"
        },
    "ID_dataRaces": {
        "checkPoint": "访问共享数据应遵循合理的同步机制",
        "level": "warning",
        "comment": "共享数据可被多个执行单位或硬件读写，需要合理控制访问的先后顺序。",
        "tag": "security",
        "standard": "ISO/IEC 9899:2011 5.1.2.4(3)-undefined,ISO/IEC 9899:2011 5.1.2.4(20)-undefined,ISO/IEC 9899:2011 5.1.2.4(25)-undefined",
        "reference": "CWE-362,C++ Core Guidelines CP.2"
        },
    "ID_TOCTOU": {
        "checkPoint": "避免在一个事务中通过路径多次访问同一文件",
        "level": "warning",
        "comment": "攻击者可以在两次通过路径访问文件的中途对文件做手脚，从而造成不良后果。",
        "tag": "security",
        "standard": "ISO/IEC 9899:2011 7.21.5.3(3)",
        "reference": "CWE-367"
        },
    "ID_hijack": {
        "checkPoint": "预判用户输入造成的不良后果",
        "level": "warning",
        "comment": "须对用户输入的脚本、路径、资源请求等信息进行预判，对产生不良后果的输入予以拒绝。",
        "tag": "security",
        "reference": "CWE-89,CWE-23,CWE-73"
        },
    "ID_bufferOverflow": {
        "checkPoint": "对缓冲区的读写应在有效边界内进行",
        "level": "warning",
        "comment": "对缓冲区的读写应在有效边界内进行。",
        "tag": "buffer",
        "related": "ID_arrayIndexOverflow,ID_unsafeStringFunction",
        "reference": "CWE-119,CWE-131,CWE-788"
        },
    "ID_protectedData": {
        "checkPoint": "类的非常量数据成员不应定义为 protected",
        "level": "suggestion",
        "comment": "protected 数据成员在派生类中仍可随意读写，破坏了封装理念。",
        "tag": "type",
        "related": "ID_mixPublicPrivateData,ID_nonPrivateData",
        "reference": "C++ Core Guidelines C.9,C++ Core Guidelines C.133"
        },
    "ID_mixPublicPrivateData": {
        "checkPoint": "类不应既有 public 数据成员又有 private 数据成员",
        "level": "suggestion",
        "comment": "类不应既有 public 数据成员又有 private 数据成员。",
        "tag": "type",
        "related": "ID_nonPrivateData,ID_protectedData",
        "reference": "C++ Core Guidelines C.9,C++ Core Guidelines C.134"
        },
    "ID_returnRValueReference": {
        "checkPoint": "函数不应返回右值引用",
        "level": "suggestion",
        "comment": "函数返回右值引用的实际价值有限，而且很容易产生错误。",
        "tag": "function",
        "related": "ID_localAddressFlowOut",
        "reference": "C++ Core Guidelines F.45"
        },
    "ID_returnConstObject": {
        "checkPoint": "函数返回值不应为 const 对象",
        "level": "suggestion",
        "comment": "函数返回 const 对象不利于移动构造或移动赋值等机制，也可能本意是返回引用，但遗漏了引用符号。",
        "tag": "function",
        "reference": "C++ Core Guidelines F.20"
        },
    "ID_nonPrivateData": {
        "checkPoint": "类的非常量数据成员均应为 private",
        "level": "suggestion",
        "comment": "类的数据成员均应设为私有，对外统一由成员函数提供访问方法。",
        "tag": "type",
        "related": "ID_protectedData,ID_mixPublicPrivateData",
        "reference": "MISRA C++ 2008 11-0-1"
        },
    "ID_unsuitableStructTag": {
        "checkPoint": "存在构造、析构或虚函数的类不应采用 struct 关键字",
        "level": "suggestion",
        "comment": "为了便于区分简单结构体和具有封装或多态属性的类，建议 struct 关键字只用于结构体，其他情况均采用 class 关键字。",
        "tag": "type",
        "reference": "C++ Core Guidelines C.2,C++ Core Guidelines C.8"
        },
    "ID_improperAuthorization": {
        "checkPoint": "落实对用户的权限管理",
        "level": "warning",
        "comment": "需落实对用户的权限管理，对无权限的请求予以拒绝。",
        "tag": "security",
        "reference": "CWE-285"
        },
    "ID_redundantSemicolon": {
        "checkPoint": "不应存在多余的分号",
        "level": "suggestion",
        "comment": "多余的分号使代码显得繁琐，也可能包含某种错误，应该去掉。",
        "tag": "style"
        },
    "ID_specialComment": {
        "checkPoint": "关注 TODO、FIXME、XXX、BUG 等特殊注释",
        "level": "warning",
        "comment": "TODO、FIXME、XXX、BUG 等特殊注释表示代码中存在问题，这种问题不应被遗忘，应有计划地予以解决。",
        "tag": "precompile",
        "reference": "CWE-546"
        },
    "ID_nestedComment": {
        "checkPoint": "注释不可嵌套",
        "level": "warning",
        "comment": "嵌套的 /*...*/ 注释不符合标准，/* 与 */ 之间不应出现 /*，某些编译器可以接受嵌套，但不具备可移植性。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.4.9(1),ISO/IEC 9899:2011 6.4.9(1)",
        "reference": "MISRA C 2004 2.3,MISRA C 2012 3.1,MISRA C++ 2008 2-7-1"
        },
    "ID_badCommentPosition": {
        "checkPoint": "注释应出现在合理的位置",
        "level": "suggestion",
        "comment": "注释应出现在段落的前后或行尾，不应出现在行首或中间，否则对阅读产生较大干扰，也可能产生标准未定义的问题。",
        "tag": "precompile"
        },
    "ID_badBackslash": {
        "checkPoint": "除转义字符、宏定义之外不应使用反斜杠",
        "level": "warning",
        "comment": "反斜杠可用于标识转义字符，也可用于实现“伪换行”，即代码换行显示但在语法上并没有换行，一般用于宏定义，除此之外不应再使用反斜杠，否则没有实际意义，也会造成混乱。",
        "tag": "precompile"
        }
}
